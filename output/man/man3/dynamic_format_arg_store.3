.TH "dynamic_format_arg_store< Context >" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
dynamic_format_arg_store< Context >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <args\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const T &arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (std::reference_wrapper< T > arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const detail::named_arg< char_type, T > &arg)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_cap, size_t new_cap_named)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const T &arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (std::reference_wrapper< T > arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const detail::named_arg< char_type, T > &arg)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_cap, size_t new_cap_named)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const T &arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (std::reference_wrapper< T > arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const detail::named_arg< char_type, T > &arg)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_cap, size_t new_cap_named)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const T &arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (std::reference_wrapper< T > arg)"
.br
.ti -1c
.RI "template<typename T > void \fBpush_back\fP (const detail::named_arg< char_type, T > &arg)"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_cap, size_t new_cap_named)"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBbasic_format_args< Context >\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename \fBContext\fP>
.br
class dynamic_format_arg_store< Context >"\\rst \fBA\fP dynamic version of \fCfmt::format_arg_store\fP\&. It's equipped with a storage to potentially temporary objects which lifetimes could be shorter than the format arguments object\&.
.PP
It can be implicitly converted into \fC~fmt\fBbasic_format_args\fP\fP for passing into type-erased formatting functions such as \fC~fmtvformat\fP\&. \\endrst 
.SH "Member Function Documentation"
.PP 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::clear ()\fC [inline]\fP"
Erase all elements from the store 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::clear ()\fC [inline]\fP"
Erase all elements from the store 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::clear ()\fC [inline]\fP"
Erase all elements from the store 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::clear ()\fC [inline]\fP"
Erase all elements from the store 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const detail::named_arg< char_type, T > & arg)\fC [inline]\fP"
Adds named argument into the dynamic store for later passing to a formatting function\&. \fCstd::reference_wrapper\fP is supported to avoid copying of the argument\&. The name is always copied into the store\&. 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const detail::named_arg< char_type, T > & arg)\fC [inline]\fP"
Adds named argument into the dynamic store for later passing to a formatting function\&. \fCstd::reference_wrapper\fP is supported to avoid copying of the argument\&. The name is always copied into the store\&. 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const detail::named_arg< char_type, T > & arg)\fC [inline]\fP"
Adds named argument into the dynamic store for later passing to a formatting function\&. \fCstd::reference_wrapper\fP is supported to avoid copying of the argument\&. The name is always copied into the store\&. 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const detail::named_arg< char_type, T > & arg)\fC [inline]\fP"
Adds named argument into the dynamic store for later passing to a formatting function\&. \fCstd::reference_wrapper\fP is supported to avoid copying of the argument\&. The name is always copied into the store\&. 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const T & arg)\fC [inline]\fP"
\\rst Adds an argument into the dynamic store for later passing to a formatting function\&.
.PP
Note that custom types and string types (but not string views) are copied into the store dynamically allocating memory if necessary\&.
.PP
Example**::
.PP
fmt::dynamic_format_arg_store<fmt::format_context> store; store\&.push_back(42); store\&.push_back('abc'); store\&.push_back(1\&.5f); std::string result = fmt::vformat('{} and {} and {}', store); \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const T & arg)\fC [inline]\fP"
\\rst Adds an argument into the dynamic store for later passing to a formatting function\&.
.PP
Note that custom types and string types (but not string views) are copied into the store dynamically allocating memory if necessary\&.
.PP
Example**::
.PP
fmt::dynamic_format_arg_store<fmt::format_context> store; store\&.push_back(42); store\&.push_back('abc'); store\&.push_back(1\&.5f); std::string result = fmt::vformat('{} and {} and {}', store); \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const T & arg)\fC [inline]\fP"
\\rst Adds an argument into the dynamic store for later passing to a formatting function\&.
.PP
Note that custom types and string types (but not string views) are copied into the store dynamically allocating memory if necessary\&.
.PP
Example**::
.PP
fmt::dynamic_format_arg_store<fmt::format_context> store; store\&.push_back(42); store\&.push_back('abc'); store\&.push_back(1\&.5f); std::string result = fmt::vformat('{} and {} and {}', store); \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (const T & arg)\fC [inline]\fP"
\\rst Adds an argument into the dynamic store for later passing to a formatting function\&.
.PP
Note that custom types and string types (but not string views) are copied into the store dynamically allocating memory if necessary\&.
.PP
Example**::
.PP
fmt::dynamic_format_arg_store<fmt::format_context> store; store\&.push_back(42); store\&.push_back('abc'); store\&.push_back(1\&.5f); std::string result = fmt::vformat('{} and {} and {}', store); \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (std::reference_wrapper< T > arg)\fC [inline]\fP"

.PP
.nf
\\rst
Adds a reference to the argument into the dynamic store for later passing to
a formatting function\&.

  Example**::

  fmt::dynamic_format_arg_store<fmt::format_context> store;
  char band[] = 'Rolling Stones';
  store\&.push_back(std::cref(band));
  band[9] = 'c'; // Changing str affects the output\&.
  std::string result = fmt::vformat('{}', store);

.fi
.PP
 result == 'Rolling Scones' \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (std::reference_wrapper< T > arg)\fC [inline]\fP"

.PP
.nf
\\rst
Adds a reference to the argument into the dynamic store for later passing to
a formatting function\&.

  Example**::

  fmt::dynamic_format_arg_store<fmt::format_context> store;
  char band[] = 'Rolling Stones';
  store\&.push_back(std::cref(band));
  band[9] = 'c'; // Changing str affects the output\&.
  std::string result = fmt::vformat('{}', store);

.fi
.PP
 result == 'Rolling Scones' \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (std::reference_wrapper< T > arg)\fC [inline]\fP"

.PP
.nf
\\rst
Adds a reference to the argument into the dynamic store for later passing to
a formatting function\&.

  Example**::

  fmt::dynamic_format_arg_store<fmt::format_context> store;
  char band[] = 'Rolling Stones';
  store\&.push_back(std::cref(band));
  band[9] = 'c'; // Changing str affects the output\&.
  std::string result = fmt::vformat('{}', store);

.fi
.PP
 result == 'Rolling Scones' \\endrst 
.SS "template<typename \fBContext\fP > template<typename T > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::push_back (std::reference_wrapper< T > arg)\fC [inline]\fP"

.PP
.nf
\\rst
Adds a reference to the argument into the dynamic store for later passing to
a formatting function\&.

  Example**::

  fmt::dynamic_format_arg_store<fmt::format_context> store;
  char band[] = 'Rolling Stones';
  store\&.push_back(std::cref(band));
  band[9] = 'c'; // Changing str affects the output\&.
  std::string result = fmt::vformat('{}', store);

.fi
.PP
 result == 'Rolling Scones' \\endrst 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::reserve (size_t new_cap, size_t new_cap_named)\fC [inline]\fP"
\\rst Reserves space to store at least \fInew_cap\fP arguments including new_cap_named* named arguments\&. \\endrst 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::reserve (size_t new_cap, size_t new_cap_named)\fC [inline]\fP"
\\rst Reserves space to store at least \fInew_cap\fP arguments including new_cap_named* named arguments\&. \\endrst 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::reserve (size_t new_cap, size_t new_cap_named)\fC [inline]\fP"
\\rst Reserves space to store at least \fInew_cap\fP arguments including new_cap_named* named arguments\&. \\endrst 
.SS "template<typename \fBContext\fP > void \fBdynamic_format_arg_store\fP< \fBContext\fP >::reserve (size_t new_cap, size_t new_cap_named)\fC [inline]\fP"
\\rst Reserves space to store at least \fInew_cap\fP arguments including new_cap_named* named arguments\&. \\endrst 

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
