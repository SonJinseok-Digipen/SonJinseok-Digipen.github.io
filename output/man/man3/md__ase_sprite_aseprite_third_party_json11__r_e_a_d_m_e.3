.TH "md__ase_sprite_aseprite_third_party_json11__r_e_a_d_m_e" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__ase_sprite_aseprite_third_party_json11__r_e_a_d_m_e \- json11 
.PP
json11 is a tiny JSON library for C++11, providing JSON parsing and serialization\&.
.PP
The core object provided by the library is \fBjson11::Json\fP\&. \fBA\fP Json object represents any JSON value: null, bool, number (int or double), string (std::string), array (std::vector), or object (std::map)\&.
.PP
Json objects act like values\&. They can be assigned, copied, moved, compared for equality or order, and so on\&. There are also helper methods Json::dump, to serialize a Json to a string, and Json::parse (static) to parse a std::string as a Json object\&.
.PP
It's easy to make a JSON object with C++11's new initializer syntax: 
.PP
.nf
Json my_json = Json::object {
    { 'key1', 'value1' },
    { 'key2', false },
    { 'key3', Json::array { 1, 2, 3 } },
};
std::string json_str = my_json\&.dump();

.fi
.PP
 There are also implicit constructors that allow standard and user-defined types to be automatically converted to JSON\&. For example: 
.PP
.nf
class Point {
public:
    int x;
    int y;
    Point (int x, int y) : x(x), y(y) {}
    Json to_json() const { return Json::array { x, y }; }
};

std::vector<Point> points = { { 1, 2 }, { 10, 20 }, { 100, 200 } };
std::string points_json = Json(points)\&.dump();

.fi
.PP
 JSON values can have their values queried and inspected: 
.PP
.nf
Json json = Json::array { Json::object { { 'k', 'v' } } };
std::string str = json[0]['k']\&.string_value();

.fi
.PP
 For more documentation see \fBjson11\&.hpp\fP\&. 
