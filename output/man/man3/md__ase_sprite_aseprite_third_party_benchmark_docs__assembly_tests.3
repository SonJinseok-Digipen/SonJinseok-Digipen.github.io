.TH "md__ase_sprite_aseprite_third_party_benchmark_docs__assembly_tests" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__ase_sprite_aseprite_third_party_benchmark_docs__assembly_tests \- Assembly Tests 
.PP
The Benchmark library provides a number of functions whose primary purpose in to affect assembly generation, including \fCDoNotOptimize\fP and \fCClobberMemory\fP\&. In addition there are other functions, such as \fCKeepRunning\fP, for which generating good assembly is paramount\&.
.PP
For these functions it's important to have tests that verify the correctness and quality of the implementation\&. This requires testing the code generated by the compiler\&.
.PP
This document describes how the Benchmark library tests compiler output, as well as how to properly write new tests\&.
.SH "Anatomy of a Test"
.PP
Writing a test has two steps:
.PP
.IP "\(bu" 2
Write the code you want to generate assembly for\&.
.IP "\(bu" 2
Add \fC// CHECK\fP lines to match against the verified assembly\&.
.PP
.PP
Example: 
.PP
.nf
 {c++}

// CHECK\-LABEL: test_add:
extern "C" int test_add() {
    extern int ExternInt;
    return ExternInt + 1;

    // CHECK: movl ExternInt(%rip), %eax
    // CHECK: addl %eax
    // CHECK: ret
}

.fi
.PP
.SS "LLVM Filecheck"
\fCLLVM's Filecheck\fP is used to test the generated assembly against the \fC// CHECK\fP lines specified in the tests source file\&. Please see the documentation linked above for information on how to write \fCCHECK\fP directives\&.
.SS "Tips and Tricks:"
.IP "\(bu" 2
Tests should match the minimal amount of output required to establish correctness\&. \fCCHECK\fP directives don't have to match on the exact next line after the previous match, so tests should omit checks for unimportant bits of assembly\&. (\fC\fCCHECK-NEXT\fP\fP can be used to ensure a match occurs exactly after the previous match)\&.
.IP "\(bu" 2
The tests are compiled with \fC-O3 -g0\fP\&. So we're only testing the optimized output\&.
.IP "\(bu" 2
The assembly output is further cleaned up using \fCtools/strip_asm\&.py\fP\&. This removes comments, assembler directives, and unused labels before the test is run\&.
.IP "\(bu" 2
The generated and stripped assembly file for a test is output under \fC<build-directory>/test/<test-name>\&.s\fP
.IP "\(bu" 2
Filecheck supports using \fC\fCCHECK\fP prefixes\fP to specify lines that should only match in certain situations\&. The Benchmark tests use \fCCHECK-CLANG\fP and \fCCHECK-GNU\fP for lines that are only expected to match Clang or GCC's output respectively\&. Normal \fCCHECK\fP lines match against all compilers\&. (Note: \fCCHECK-NOT\fP and \fCCHECK-LABEL\fP are NOT prefixes\&. They are versions of non-prefixed \fCCHECK\fP lines)
.IP "\(bu" 2
Use \fCextern 'C'\fP to disable name mangling for specific functions\&. This makes them easier to name in the \fCCHECK\fP lines\&.
.PP
.SH "Problems Writing Portable Tests"
.PP
Writing tests which check the code generated by a compiler are inherently non-portable\&. Different compilers and even different compiler versions may generate entirely different code\&. The Benchmark tests must tolerate this\&.
.PP
LLVM Filecheck provides a number of mechanisms to help write 'more portable' tests; including \fCmatching using regular expressions\fP, allowing the creation of \fCnamed variables\fP for later matching, and \fCchecking non-sequential matches\fP\&.
.SS "Capturing Variables"
For example, say GCC stores a variable in a register but Clang stores it in memory\&. To write a test that tolerates both cases we 'capture' the destination of the store, and then use the captured expression to write the remainder of the test\&.
.PP
.PP
.nf
 {c++}
// CHECK\-LABEL: test_div_no_op_into_shr:
extern "C" void test_div_no_op_into_shr(int value) {
    int divisor = 2;
    benchmark::DoNotOptimize(divisor); // hide the value from the optimizer
    return value / divisor;

    // CHECK: movl $2, [[DEST:\&.*]]
    // CHECK: idivl [[DEST]]
    // CHECK: ret
}
.fi
.PP
.SS "Using Regular Expressions to Match Differing Output"
Often tests require testing assembly lines which may subtly differ between compilers or compiler versions\&. \fBA\fP common example of this is matching stack frame addresses\&. In this case regular expressions can be used to match the differing bits of output\&. For example:
.PP
.PP
.nf
 {c++}
int ExternInt;
struct Point { int x, y, z; };

// CHECK\-LABEL: test_store_point:
extern "C" void test_store_point() {
    Point p{ExternInt, ExternInt, ExternInt};
    benchmark::DoNotOptimize(p);

    // CHECK: movl ExternInt(%rip), %eax
    // CHECK: movl %eax, \-{{[0\-9]+}}(%rsp)
    // CHECK: movl %eax, \-{{[0\-9]+}}(%rsp)
    // CHECK: movl %eax, \-{{[0\-9]+}}(%rsp)
    // CHECK: ret
}
.fi
.PP
.SH "Current Requirements and Limitations"
.PP
The tests require Filecheck to be installed along the \fCPATH\fP of the build machine\&. Otherwise the tests will be disabled\&.
.PP
Additionally, as mentioned in the previous section, codegen tests are inherently non-portable\&. Currently the tests are limited to:
.PP
.IP "\(bu" 2
x86_64 targets\&.
.IP "\(bu" 2
Compiled with GCC or Clang
.PP
.PP
Further work could be done, at least on a limited basis, to extend the tests to other architectures and compilers (using \fCCHECK\fP prefixes)\&.
.PP
Furthermore, the tests fail for builds which specify additional flags that modify code generation, including \fC--coverage\fP or \fC-fsanitize=\fP\&. 
