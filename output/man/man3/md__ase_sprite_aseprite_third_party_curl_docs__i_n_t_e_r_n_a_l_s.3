.TH "md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s \- curl internals 
.PP

.IP "\(bu" 2
\fBIntro\fP
.IP "\(bu" 2
\fBgit\fP
.IP "\(bu" 2
\fBPortability\fP
.IP "\(bu" 2
\fBWindows vs Unix\fP
.IP "\(bu" 2
\fBLibrary\fP
.IP "  \(bu" 4
\fB`Curl_connect`\fP
.IP "  \(bu" 4
\fB`multi_do`\fP
.IP "  \(bu" 4
\fB`Curl_readwrite`\fP
.IP "  \(bu" 4
\fB`multi_done`\fP
.IP "  \(bu" 4
\fB`Curl_disconnect`\fP
.PP

.IP "\(bu" 2
\fBHTTP(S)\fP
.IP "\(bu" 2
\fBFTP\fP
.IP "\(bu" 2
\fBKerberos\fP
.IP "\(bu" 2
\fBTELNET\fP
.IP "\(bu" 2
\fBFILE\fP
.IP "\(bu" 2
\fBSMB\fP
.IP "\(bu" 2
\fBLDAP\fP
.IP "\(bu" 2
\fBE-mail\fP
.IP "\(bu" 2
\fBGeneral\fP
.IP "\(bu" 2
\fBPersistent Connections\fP
.IP "\(bu" 2
\fBmulti interface/non-blocking\fP
.IP "\(bu" 2
\fBSSL libraries\fP
.IP "\(bu" 2
\fBLibrary Symbols\fP
.IP "\(bu" 2
\fBReturn Codes and Informationals\fP
.IP "\(bu" 2
\fBAP/ABI\fP
.IP "\(bu" 2
\fBClient\fP
.IP "\(bu" 2
\fBMemory Debugging\fP
.IP "\(bu" 2
\fBTest Suite\fP
.IP "\(bu" 2
\fBAsynchronous name resolves\fP
.IP "  \(bu" 4
\fBc-ares\fP
.PP

.IP "\(bu" 2
\fB`curl_off_t`\fP
.IP "\(bu" 2
\fBcurlx\fP
.IP "\(bu" 2
\fBContent Encoding\fP
.IP "\(bu" 2
\fB`hostip\&.c` explained\fP
.IP "\(bu" 2
\fBTrack Down Memory Leaks\fP
.IP "\(bu" 2
\fB`multi_socket`\fP
.IP "\(bu" 2
\fBStructs in libcurl\fP
.IP "  \(bu" 4
\fBCurl_easy\fP
.IP "  \(bu" 4
\fBconnectdata\fP
.IP "  \(bu" 4
\fBCurl_multi\fP
.IP "  \(bu" 4
\fBCurl_handler\fP
.IP "  \(bu" 4
\fBconncache\fP
.IP "  \(bu" 4
\fBCurl_share\fP
.IP "  \(bu" 4
\fBCookieInfo\fP
.PP

.PP
.PP
 
.SH "Intro"
.PP
This project is split in two\&. The library and the client\&. The client part uses the library, but the library is designed to allow other applications to use it\&.
.PP
The largest amount of code and complexity is in the library part\&.
.PP
 
.SH "git"
.PP
All changes to the sources are committed to the git repository as soon as they're somewhat verified to work\&. Changes shall be committed as independently as possible so that individual changes can be easily spotted and tracked afterwards\&.
.PP
Tagging shall be used extensively, and by the time we release new archives we should tag the sources with a name similar to the released version number\&.
.PP
 
.SH "Portability"
.PP
We write curl and libcurl to compile with C89 compilers\&. On 32-bit and up machines\&. Most of libcurl assumes more or less POSIX compliance but that's not a requirement\&.
.PP
We write libcurl to build and work with lots of third party tools, and we want it to remain functional and buildable with these and later versions (older versions may still work but is not what we work hard to maintain):
.SS "Dependencies"
.IP "\(bu" 2
OpenSSL 0\&.9\&.7
.IP "\(bu" 2
GnuTLS 3\&.1\&.10
.IP "\(bu" 2
zlib 1\&.1\&.4
.IP "\(bu" 2
libssh2 1\&.0
.IP "\(bu" 2
c-ares 1\&.16\&.0
.IP "\(bu" 2
libidn2 2\&.0\&.0
.IP "\(bu" 2
wolfSSL 2\&.0\&.0
.IP "\(bu" 2
openldap 2\&.0
.IP "\(bu" 2
MIT Kerberos 1\&.2\&.4
.IP "\(bu" 2
GSKit V5R3M0
.IP "\(bu" 2
NSS 3\&.14\&.x
.IP "\(bu" 2
Heimdal ?
.IP "\(bu" 2
nghttp2 1\&.12\&.0
.IP "\(bu" 2
WinSock 2\&.2 (on Windows 95+ and Windows CE \&.NET 4\&.1+)
.PP
.SS "Operating Systems"
On systems where configure runs, we aim at working on them all - if they have a suitable C compiler\&. On systems that don't run configure, we strive to keep curl running correctly on:
.PP
.IP "\(bu" 2
Windows 98
.IP "\(bu" 2
AS/400 V5R3M0
.IP "\(bu" 2
Symbian 9\&.1
.IP "\(bu" 2
Windows CE ?
.IP "\(bu" 2
TPF ?
.PP
.SS "Build tools"
When writing code (mostly for generating stuff included in release tarballs) we use a few 'build tools' and we make sure that we remain functional with these versions:
.PP
.IP "\(bu" 2
GNU Libtool 1\&.4\&.2
.IP "\(bu" 2
GNU Autoconf 2\&.57
.IP "\(bu" 2
GNU Automake 1\&.7
.IP "\(bu" 2
GNU M4 1\&.4
.IP "\(bu" 2
perl 5\&.004
.IP "\(bu" 2
roffit 0\&.5
.IP "\(bu" 2
groff ? (any version that supports \fCgroff -Tps -man [in] [out]\fP)
.IP "\(bu" 2
ps2pdf (gs) ?
.PP
.PP
 
.SH "Windows vs Unix"
.PP
There are a few differences in how to program curl the Unix way compared to the Windows way\&. Perhaps the four most notable details are:
.PP
.IP "1." 4
Different function names for socket operations\&.
.PP
In curl, this is solved with defines and macros, so that the source looks the same in all places except for the header file that defines them\&. The macros in use are \fCsclose()\fP, \fCsread()\fP and \fCswrite()\fP\&.
.IP "2." 4
Windows requires a couple of init calls for the socket stuff\&.
.PP
That's taken care of by the \fCcurl_global_init()\fP call, but if other libs also do it etc there might be reasons for applications to alter that behavior\&.
.PP
We require WinSock version 2\&.2 and load this version during global init\&.
.IP "3." 4
The file descriptors for network communication and file operations are not as easily interchangeable as in Unix\&.
.PP
We avoid this by not trying any funny tricks on file descriptors\&.
.IP "4." 4
When writing data to stdout, Windows makes end-of-lines the DOS way, thus destroying binary data, although you do want that conversion if it is text coming through\&.\&.\&. (sigh)
.PP
We set stdout to binary under windows
.PP
.PP
Inside the source code, We make an effort to avoid \fC#ifdef [Your OS]\fP\&. All conditionals that deal with features \fIshould\fP instead be in the format \fC#ifdef HAVE_THAT_WEIRD_FUNCTION\fP\&. Since Windows can't run configure scripts, we maintain a \fCcurl_config-win32\&.h\fP file in lib directory that is supposed to look exactly like a \fCcurl_config\&.h\fP file would have looked like on a Windows machine!
.PP
Generally speaking: always remember that this will be compiled on dozens of operating systems\&. Don't walk on the edge!
.PP
 
.SH "Library"
.PP
(See \fBStructs in libcurl\fP for the separate section describing all major internal structs and their purposes\&.)
.PP
There are plenty of entry points to the library, namely each publicly defined function that libcurl offers to applications\&. All of those functions are rather small and easy-to-follow\&. All the ones prefixed with \fCcurl_easy\fP are put in the \fClib/easy\&.c\fP file\&.
.PP
\fCcurl_global_init()\fP and \fCcurl_global_cleanup()\fP should be called by the application to initialize and clean up global stuff in the library\&. As of today, it can handle the global SSL initialization if SSL is enabled and it can initialize the socket layer on Windows machines\&. libcurl itself has no 'global' scope\&.
.PP
All printf()-style functions use the supplied clones in \fClib/mprintf\&.c\fP\&. This makes sure we stay absolutely platform independent\&.
.PP
\fC\fCcurl_easy_init()\fP\fP allocates an internal struct and makes some initializations\&. The returned handle does not reveal internals\&. This is the \fC\fBCurl_easy\fP\fP struct which works as an 'anchor' struct for all \fCcurl_easy\fP functions\&. All connections performed will get connect-specific data allocated that should be used for things related to particular connections/requests\&.
.PP
\fC\fCcurl_easy_setopt()\fP\fP takes three arguments, where the option stuff must be passed in pairs: the parameter-ID and the parameter-value\&. The list of options is documented in the man page\&. This function mainly sets things in the \fC\fBCurl_easy\fP\fP struct\&.
.PP
\fCcurl_easy_perform()\fP is just a wrapper function that makes use of the multi API\&. It basically calls \fCcurl_multi_init()\fP, \fCcurl_multi_add_handle()\fP, \fCcurl_multi_wait()\fP, and \fCcurl_multi_perform()\fP until the transfer is done and then returns\&.
.PP
Some of the most important key functions in \fCurl\&.c\fP are called from \fCmulti\&.c\fP when certain key steps are to be made in the transfer operation\&.
.PP
 
.SS "Curl_connect()"
Analyzes the URL, it separates the different components and connects to the remote host\&. This may involve using a proxy and/or using SSL\&. The \fCCurl_resolv()\fP function in \fClib/hostip\&.c\fP is used for looking up host names (it does then use the proper underlying method, which may vary between platforms and builds)\&.
.PP
When \fCCurl_connect\fP is done, we are connected to the remote site\&. Then it is time to tell the server to get a document/file\&. \fCCurl_do()\fP arranges this\&.
.PP
This function makes sure there's an allocated and initiated \fCconnectdata\fP struct that is used for this particular connection only (although there may be several requests performed on the same connect)\&. \fBA\fP bunch of things are initialized/inherited from the \fC\fBCurl_easy\fP\fP struct\&.
.PP
 
.SS "multi_do()"
\fCmulti_do()\fP makes sure the proper protocol-specific function is called\&. The functions are named after the protocols they handle\&.
.PP
The protocol-specific functions of course deal with protocol-specific negotiations and setup\&. When they're ready to start the actual file transfer they call the \fCCurl_setup_transfer()\fP function (in \fClib/transfer\&.c\fP) to setup the transfer and returns\&.
.PP
If this DO function fails and the connection is being re-used, libcurl will then close this connection, setup a new connection and re-issue the DO request on that\&. This is because there is no way to be perfectly sure that we have discovered a dead connection before the DO function and thus we might wrongly be re-using a connection that was closed by the remote peer\&.
.PP
 
.SS "Curl_readwrite()"
Called during the transfer of the actual protocol payload\&.
.PP
During transfer, the progress functions in \fClib/progress\&.c\fP are called at frequent intervals (or at the user's choice, a specified callback might get called)\&. The speedcheck functions in \fClib/speedcheck\&.c\fP are also used to verify that the transfer is as fast as required\&.
.PP
 
.SS "multi_done()"
Called after a transfer is done\&. This function takes care of everything that has to be done after a transfer\&. This function attempts to leave matters in a state so that \fCmulti_do()\fP should be possible to call again on the same connection (in a persistent connection case)\&. It might also soon be closed with \fCCurl_disconnect()\fP\&.
.PP
 
.SS "Curl_disconnect()"
When doing normal connections and transfers, no one ever tries to close any connections so this is not normally called when \fCcurl_easy_perform()\fP is used\&. This function is only used when we are certain that no more transfers are going to be made on the connection\&. It can be also closed by force, or it can be called to make sure that libcurl doesn't keep too many connections alive at the same time\&.
.PP
This function cleans up all resources that are associated with a single connection\&.
.PP
 
.SH "HTTP(S)"
.PP
\fBHTTP\fP offers a lot and is the protocol in curl that uses the most lines of code\&. There is a special file \fClib/formdata\&.c\fP that offers all the multipart post functions\&.
.PP
base64-functions for user+password stuff (and more) is in \fClib/base64\&.c\fP and all functions for parsing and sending cookies are found in \fClib/cookie\&.c\fP\&.
.PP
HTTPS uses in almost every case the same procedure as \fBHTTP\fP, with only two exceptions: the connect procedure is different and the function used to read or write from the socket is different, although the latter fact is hidden in the source by the use of \fCCurl_read()\fP for reading and \fCCurl_write()\fP for writing data to the remote server\&.
.PP
\fChttp_chunks\&.c\fP contains functions that understands \fBHTTP\fP 1\&.1 chunked transfer encoding\&.
.PP
An interesting detail with the HTTP(S) request, is the \fCCurl_add_buffer()\fP series of functions we use\&. They append data to one single buffer, and when the building is finished the entire request is sent off in one single write\&. This is done this way to overcome problems with flawed firewalls and lame servers\&.
.PP
 
.SH "FTP"
.PP
The \fCCurl_if2ip()\fP function can be used for getting the IP number of a specified network interface, and it resides in \fClib/if2ip\&.c\fP\&.
.PP
\fCCurl_ftpsendf()\fP is used for sending \fBFTP\fP commands to the remote server\&. It was made a separate function to prevent us programmers from forgetting that they must be CRLF terminated\&. They must also be sent in one single \fCwrite()\fP to make firewalls and similar happy\&.
.PP
 
.SH "Kerberos"
.PP
Kerberos support is mainly in \fClib/krb5\&.c\fP but also \fCcurl_sasl_sspi\&.c\fP and \fCcurl_sasl_gssapi\&.c\fP for the email protocols and \fCsocks_gssapi\&.c\fP and \fCsocks_sspi\&.c\fP for SOCKS5 proxy specifics\&.
.PP
 
.SH "TELNET"
.PP
Telnet is implemented in \fClib/telnet\&.c\fP\&.
.PP
 
.SH "FILE"
.PP
The \fCfile://\fP protocol is dealt with in \fClib/file\&.c\fP\&.
.PP
 
.SH "SMB"
.PP
The \fCsmb://\fP protocol is dealt with in \fClib/smb\&.c\fP\&.
.PP
 
.SH "LDAP"
.PP
Everything LDAP is in \fClib/ldap\&.c\fP and \fClib/openldap\&.c\fP\&.
.PP
 
.SH "E-mail"
.PP
The e-mail related source code is in \fClib/imap\&.c\fP, \fClib/pop3\&.c\fP and \fClib/smtp\&.c\fP\&.
.PP
 
.SH "General"
.PP
URL encoding and decoding, called escaping and unescaping in the source code, is found in \fClib/escape\&.c\fP\&.
.PP
While transferring data in \fCTransfer()\fP a few functions might get used\&. \fCcurl_getdate()\fP in \fClib/parsedate\&.c\fP is for \fBHTTP\fP date comparisons (and more)\&.
.PP
\fClib/getenv\&.c\fP offers \fCcurl_getenv()\fP which is for reading environment variables in a neat platform independent way\&. That's used in the client, but also in \fClib/url\&.c\fP when checking the proxy environment variables\&. Note that contrary to the normal unix \fCgetenv()\fP, this returns an allocated buffer that must be \fCfree()\fPed after use\&.
.PP
\fClib/netrc\&.c\fP holds the \fC\&.netrc\fP parser\&.
.PP
\fClib/timeval\&.c\fP features replacement functions for systems that don't have \fCgettimeofday()\fP and a few support functions for timeval conversions\&.
.PP
\fBA\fP function named \fCcurl_version()\fP that returns the full curl version string is found in \fClib/version\&.c\fP\&.
.PP
 
.SH "Persistent Connections"
.PP
The persistent connection support in libcurl requires some considerations on how to do things inside of the library\&.
.PP
.IP "\(bu" 2
The \fC\fBCurl_easy\fP\fP struct returned in the \fC\fCcurl_easy_init()\fP\fP call must never hold connection-oriented data\&. It is meant to hold the root data as well as all the options etc that the library-user may choose\&.
.IP "\(bu" 2
The \fC\fBCurl_easy\fP\fP struct holds the 'connection cache' (an array of pointers to \fCconnectdata\fP structs)\&.
.IP "\(bu" 2
This enables the 'curl handle' to be reused on subsequent transfers\&.
.IP "\(bu" 2
When libcurl is told to perform a transfer, it first checks for an already existing connection in the cache that we can use\&. Otherwise it creates a new one and adds that to the cache\&. If the cache is full already when a new connection is added, it will first close the oldest unused one\&.
.IP "\(bu" 2
When the transfer operation is complete, the connection is left open\&. Particular options may tell libcurl not to, and protocols may signal closure on connections and then they won't be kept open, of course\&.
.IP "\(bu" 2
When \fCcurl_easy_cleanup()\fP is called, we close all still opened connections, unless of course the multi interface 'owns' the connections\&.
.PP
.PP
The curl handle must be re-used in order for the persistent connections to work\&.
.PP
 
.SH "multi interface/non-blocking"
.PP
The multi interface is a non-blocking interface to the library\&. To make that interface work as well as possible, no low-level functions within libcurl must be written to work in a blocking manner\&. (There are still a few spots violating this rule\&.)
.PP
One of the primary reasons we introduced c-ares support was to allow the name resolve phase to be perfectly non-blocking as well\&.
.PP
The \fBFTP\fP and the SFTP/SCP protocols are examples of how we adapt and adjust the code to allow non-blocking operations even on multi-stage command- response protocols\&. They are built around state machines that return when they would otherwise block waiting for data\&. The DICT, LDAP and \fBTELNET\fP protocols are crappy examples and they are subject for rewrite in the future to better fit the libcurl protocol family\&.
.PP
 
.SH "SSL libraries"
.PP
Originally libcurl supported SSLeay for SSL/TLS transports, but that was then extended to its successor OpenSSL but has since also been extended to several other SSL/TLS libraries and we expect and hope to further extend the support in future libcurl versions\&.
.PP
To deal with this internally in the best way possible, we have a generic SSL function API as provided by the \fCvtls/vtls\&.[ch]\fP system, and they are the only SSL functions we must use from within libcurl\&. vtls is then crafted to use the appropriate lower-level function calls to whatever SSL library that is in use\&. For example \fCvtls/openssl\&.[ch]\fP for the OpenSSL library\&.
.PP
 
.SH "Library Symbols"
.PP
All symbols used internally in libcurl must use a \fCCurl_\fP prefix if they're used in more than a single file\&. Single-file symbols must be made static\&. Public ('exported') symbols must use a \fCcurl_\fP prefix\&. (There are exceptions, but they are to be changed to follow this pattern in future versions\&.) Public API functions are marked with \fCCURL_EXTERN\fP in the public header files so that all others can be hidden on platforms where this is possible\&.
.PP
 
.SH "Return Codes and Informationals"
.PP
I've made things simple\&. Almost every function in libcurl returns a CURLcode, that must be \fCCURLE_OK\fP if everything is OK or otherwise a suitable error code as the \fC\fBcurl/curl\&.h\fP\fP include file defines\&. The very spot that detects an error must use the \fCCurl_failf()\fP function to set the human-readable error description\&.
.PP
In aiding the user to understand what's happening and to debug curl usage, we must supply a fair number of informational messages by using the \fCCurl_infof()\fP function\&. Those messages are only displayed when the user explicitly asks for them\&. They are best used when revealing information that isn't otherwise obvious\&.
.PP
 
.SH "API/ABI"
.PP
We make an effort to not export or show internals or how internals work, as that makes it easier to keep a solid API/ABI over time\&. See docs/libcurl/ABI for our promise to users\&.
.PP
 
.SH "Client"
.PP
\fCmain()\fP resides in \fCsrc/tool_main\&.c\fP\&.
.PP
\fCsrc/tool_hugehelp\&.c\fP is automatically generated by the \fCmkhelp\&.pl\fP perl script to display the complete 'manual' and the \fCsrc/tool_urlglob\&.c\fP file holds the functions used for the URL-'globbing' support\&. Globbing in the sense that the \fC{}\fP and \fC[]\fP expansion stuff is there\&.
.PP
The client mostly sets up its \fCconfig\fP struct properly, then it calls the \fCcurl_easy_*()\fP functions of the library and when it gets back control after the \fCcurl_easy_perform()\fP it cleans up the library, checks status and exits\&.
.PP
When the operation is done, the \fCourWriteOut()\fP function in \fCsrc/writeout\&.c\fP may be called to report about the operation\&. That function is mostly using the \fCcurl_easy_getinfo()\fP function to extract useful information from the curl session\&.
.PP
It may loop and do all this several times if many URLs were specified on the command line or config file\&.
.PP
 
.SH "Memory Debugging"
.PP
The file \fClib/memdebug\&.c\fP contains debug-versions of a few functions\&. Functions such as \fCmalloc()\fP, \fCfree()\fP, \fCfopen()\fP, \fCfclose()\fP, etc that somehow deal with resources that might give us problems if we 'leak' them\&. The functions in the memdebug system do nothing fancy, they do their normal function and then log information about what they just did\&. The logged data can then be analyzed after a complete session,
.PP
\fCmemanalyze\&.pl\fP is the perl script present in \fCtests/\fP that analyzes a log file generated by the memory tracking system\&. It detects if resources are allocated but never freed and other kinds of errors related to resource management\&.
.PP
Internally, definition of preprocessor symbol \fCDEBUGBUILD\fP restricts code which is only compiled for debug enabled builds\&. And symbol \fCCURLDEBUG\fP is used to differentiate code which is \fIonly\fP used for memory tracking/debugging\&.
.PP
Use \fC-DCURLDEBUG\fP when compiling to enable memory debugging, this is also switched on by running configure with \fC--enable-curldebug\fP\&. Use \fC-DDEBUGBUILD\fP when compiling to enable a debug build or run configure with \fC--enable-debug\fP\&.
.PP
\fCcurl --version\fP will list 'Debug' feature for debug enabled builds, and will list 'TrackMemory' feature for curl debug memory tracking capable builds\&. These features are independent and can be controlled when running the configure script\&. When \fC--enable-debug\fP is given both features will be enabled, unless some restriction prevents memory tracking from being used\&.
.PP
 
.SH "Test Suite"
.PP
The test suite is placed in its own subdirectory directly off the root in the curl archive tree, and it contains a bunch of scripts and a lot of test case data\&.
.PP
The main test script is \fCruntests\&.pl\fP that will invoke test servers like \fChttpserver\&.pl\fP and \fCftpserver\&.pl\fP before all the test cases are performed\&. The test suite currently only runs on Unix-like platforms\&.
.PP
You'll find a description of the test suite in the \fCtests/README\fP file, and the test case data files in the \fCtests/FILEFORMAT\fP file\&.
.PP
The test suite automatically detects if curl was built with the memory debugging enabled, and if it was, it will detect memory leaks, too\&.
.PP
 
.SH "Asynchronous name resolves"
.PP
libcurl can be built to do name resolves asynchronously, using either the normal resolver in a threaded manner or by using c-ares\&.
.PP
 
.SS "<a href='https://c-ares\&.org/' >c-ares</a>"
.SS "Build libcurl to use a c-ares"
.IP "1." 4
\&./configure --enable-ares=/path/to/ares/install
.IP "2." 4
make
.PP
.SS "c-ares on win32"
First I compiled c-ares\&. I changed the default C runtime library to be the single-threaded rather than the multi-threaded (this seems to be required to prevent linking errors later on)\&. Then I simply build the areslib project (the other projects adig/ahost seem to fail under MSVC)\&.
.PP
Next was libcurl\&. I opened \fC\fBlib/config-win32\&.h\fP\fP and I added a: \fC#define USE_ARES 1\fP
.PP
Next thing I did was I added the path for the ares includes to the include path, and the libares\&.lib to the libraries\&.
.PP
Lastly, I also changed libcurl to be single-threaded rather than multi-threaded, again this was to prevent some duplicate symbol errors\&. I'm not sure why I needed to change everything to single-threaded, but when I didn't I got redefinition errors for several CRT functions (\fCmalloc()\fP, \fCstricmp()\fP, etc\&.)
.PP
 
.SH "<tt>curl_off_t</tt>"
.PP
\fCcurl_off_t\fP is a data type provided by the external libcurl include headers\&. It is the type meant to be used for the \fC\fCcurl_easy_setopt()\fP\fP options that end with LARGE\&. The type is 64-bit large on most modern platforms\&.
.PP
 
.SH "curlx"
.PP
The libcurl source code offers a few functions by source only\&. They are not part of the official libcurl API, but the source files might be useful for others so apps can optionally compile/build with these sources to gain additional functions\&.
.PP
We provide them through a single header file for easy access for apps: \fC\fBcurlx\&.h\fP\fP
.SS "<tt>curlx_strtoofft()</tt>"
\fBA\fP macro that converts a string containing a number to a \fCcurl_off_t\fP number\&. This might use the \fCcurlx_strtoll()\fP function which is provided as source code in strtoofft\&.c\&. Note that the function is only provided if no \fCstrtoll()\fP (or equivalent) function exist on your platform\&. If \fCcurl_off_t\fP is only a 32-bit number on your platform, this macro uses \fCstrtol()\fP\&.
.SS "Future"
Several functions will be removed from the public \fCcurl_\fP name space in a future libcurl release\&. They will then only become available as \fCcurlx_\fP functions instead\&. To make the transition easier, we already today provide these functions with the \fCcurlx_\fP prefix to allow sources to be built properly with the new function names\&. The concerned functions are:
.PP
.IP "\(bu" 2
\fCcurlx_getenv\fP
.IP "\(bu" 2
\fCcurlx_strequal\fP
.IP "\(bu" 2
\fCcurlx_strnequal\fP
.IP "\(bu" 2
\fCcurlx_mvsnprintf\fP
.IP "\(bu" 2
\fCcurlx_msnprintf\fP
.IP "\(bu" 2
\fCcurlx_maprintf\fP
.IP "\(bu" 2
\fCcurlx_mvaprintf\fP
.IP "\(bu" 2
\fCcurlx_msprintf\fP
.IP "\(bu" 2
\fCcurlx_mprintf\fP
.IP "\(bu" 2
\fCcurlx_mfprintf\fP
.IP "\(bu" 2
\fCcurlx_mvsprintf\fP
.IP "\(bu" 2
\fCcurlx_mvprintf\fP
.IP "\(bu" 2
\fCcurlx_mvfprintf\fP
.PP
.PP
 
.SH "Content Encoding"
.PP
.SS "About content encodings"
\fCHTTP/1\&.1\fP specifies that a client may request that a server encode its response\&. This is usually used to compress a response using one (or more) encodings from a set of commonly available compression techniques\&. These schemes include \fCdeflate\fP (the zlib algorithm), \fCgzip\fP, \fCbr\fP (brotli) and \fCcompress\fP\&. \fBA\fP client requests that the server perform an encoding by including an \fCAccept-Encoding\fP header in the request document\&. The value of the header should be one of the recognized tokens \fCdeflate\fP, \&.\&.\&. (there's a way to register new schemes/tokens, see sec 3\&.5 of the spec)\&. \fBA\fP server MAY honor the client's encoding request\&. When a response is encoded, the server includes a \fCContent-Encoding\fP header in the response\&. The value of the \fCContent-Encoding\fP header indicates which encodings were used to encode the data, in the order in which they were applied\&.
.PP
It's also possible for a client to attach priorities to different schemes so that the server knows which it prefers\&. See sec 14\&.3 of RFC 2616 for more information on the \fCAccept-Encoding\fP header\&. See sec \fC3\&.1\&.2\&.2 of RFC 7231\fP for more information on the \fCContent-Encoding\fP header\&.
.SS "Supported content encodings"
The \fCdeflate\fP, \fCgzip\fP and \fCbr\fP content encodings are supported by libcurl\&. Both regular and chunked transfers work fine\&. The zlib library is required for the \fCdeflate\fP and \fCgzip\fP encodings, while the brotli decoding library is for the \fCbr\fP encoding\&.
.SS "The libcurl interface"
To cause libcurl to request a content encoding use:
.PP
\fC\fCcurl_easy_setopt\fP\fP(curl, \fC\fCCURLOPT_ACCEPT_ENCODING\fP\fP, string)
.PP
where string is the intended value of the \fCAccept-Encoding\fP header\&.
.PP
Currently, libcurl does support multiple encodings but only understands how to process responses that use the \fCdeflate\fP, \fCgzip\fP and/or \fCbr\fP content encodings, so the only values for \fC\fCCURLOPT_ACCEPT_ENCODING\fP\fP that will work (besides \fCidentity\fP, which does nothing) are \fCdeflate\fP, \fCgzip\fP and \fCbr\fP\&. If a response is encoded using the \fCcompress\fP or methods, libcurl will return an error indicating that the response could not be decoded\&. If \fC<string>\fP is NULL no \fCAccept-Encoding\fP header is generated\&. If \fC<string>\fP is a zero-length string, then an \fCAccept-Encoding\fP header containing all supported encodings will be generated\&.
.PP
The \fC\fCCURLOPT_ACCEPT_ENCODING\fP\fP must be set to any non-NULL value for content to be automatically decoded\&. If it is not set and the server still sends encoded content (despite not having been asked), the data is returned in its raw form and the \fCContent-Encoding\fP type is not checked\&.
.SS "The curl interface"
Use the \fC\fC--compressed\fP\fP option with curl to cause it to ask servers to compress responses using any format supported by curl\&.
.PP
 
.SH "<tt>hostip\&.c</tt> explained"
.PP
The main compile-time defines to keep in mind when reading the \fChost*\&.c\fP source file are these:
.SS "<tt>CURLRES_IPV6</tt>"
this host has \fCgetaddrinfo()\fP and family, and thus we use that\&. The host may not be able to resolve IPv6, but we don't really have to take that into account\&. Hosts that aren't IPv6-enabled have \fCCURLRES_IPV4\fP defined\&.
.SS "<tt>CURLRES_ARES</tt>"
is defined if libcurl is built to use c-ares for asynchronous name resolves\&. This can be Windows or *nix\&.
.SS "<tt>CURLRES_THREADED</tt>"
is defined if libcurl is built to use threading for asynchronous name resolves\&. The name resolve will be done in a new thread, and the supported asynch API will be the same as for ares-builds\&. This is the default under (native) Windows\&.
.PP
If any of the two previous are defined, \fCCURLRES_ASYNCH\fP is defined too\&. If libcurl is not built to use an asynchronous resolver, \fCCURLRES_SYNCH\fP is defined\&.
.SS "<tt>host*\&.c</tt> sources"
The \fChost*\&.c\fP sources files are split up like this:
.PP
.IP "\(bu" 2
\fChostip\&.c\fP - method-independent resolver functions and utility functions
.IP "\(bu" 2
\fChostasyn\&.c\fP - functions for asynchronous name resolves
.IP "\(bu" 2
\fChostsyn\&.c\fP - functions for synchronous name resolves
.IP "\(bu" 2
\fCasyn-ares\&.c\fP - functions for asynchronous name resolves using c-ares
.IP "\(bu" 2
\fCasyn-thread\&.c\fP - functions for asynchronous name resolves using threads
.IP "\(bu" 2
\fChostip4\&.c\fP - IPv4 specific functions
.IP "\(bu" 2
\fChostip6\&.c\fP - IPv6 specific functions
.PP
.PP
The \fC\fBhostip\&.h\fP\fP is the single united header file for all this\&. It defines the \fCCURLRES_*\fP defines based on the \fCconfig*\&.h\fP and \fC\fBcurl_setup\&.h\fP\fP defines\&.
.PP
 
.SH "Track Down Memory Leaks"
.PP
.SS "Single-threaded"
Please note that this memory leak system is not adjusted to work in more than one thread\&. If you want/need to use it in a multi-threaded app\&. Please adjust accordingly\&.
.SS "Build"
Rebuild libcurl with \fC-DCURLDEBUG\fP (usually, rerunning configure with \fC--enable-debug\fP fixes this)\&. \fCmake clean\fP first, then \fCmake\fP so that all files are actually rebuilt properly\&. It will also make sense to build libcurl with the debug option (usually \fC-g\fP to the compiler) so that debugging it will be easier if you actually do find a leak in the library\&.
.PP
This will create a library that has memory debugging enabled\&.
.SS "Modify Your Application"
Add a line in your application code:
.PP
.PP
.nf
curl_dbg_memdebug("dump");
.fi
.PP
.PP
This will make the malloc debug system output a full trace of all resource using functions to the given file name\&. Make sure you rebuild your program and that you link with the same libcurl you built for this purpose as described above\&.
.SS "Run Your Application"
Run your program as usual\&. Watch the specified memory trace file grow\&.
.PP
Make your program exit and use the proper libcurl cleanup functions etc\&. So that all non-leaks are returned/freed properly\&.
.SS "Analyze the Flow"
Use the \fCtests/memanalyze\&.pl\fP perl script to analyze the dump file:
.PP
tests/memanalyze\&.pl dump
.PP
This now outputs a report on what resources that were allocated but never freed etc\&. This report is very fine for posting to the list!
.PP
If this doesn't produce any output, no leak was detected in libcurl\&. Then the leak is mostly likely to be in your code\&.
.PP
 
.SH "<tt>multi_socket</tt>"
.PP
Implementation of the \fCcurl_multi_socket\fP API
.PP
The main ideas of this API are simply:
.PP
.IP "1." 4
The application can use whatever event system it likes as it gets info from libcurl about what file descriptors libcurl waits for what action on\&. (The previous API returns \fCfd_sets\fP which is very \fCselect()\fP-centric)\&.
.IP "2." 4
When the application discovers action on a single socket, it calls libcurl and informs that there was action on this particular socket and libcurl can then act on that socket/transfer only and not care about any other transfers\&. (The previous API always had to scan through all the existing transfers\&.)
.PP
.PP
The idea is that \fC\fCcurl_multi_socket_action()\fP\fP calls a given callback with information about what socket to wait for what action on, and the callback only gets called if the status of that socket has changed\&.
.PP
We also added a timer callback that makes libcurl call the application when the timeout value changes, and you set that with \fC\fCcurl_multi_setopt()\fP\fP and the \fC\fCCURLMOPT_TIMERFUNCTION\fP\fP option\&. To get this to work, Internally, there's an added struct to each easy handle in which we store an 'expire time' (if any)\&. The structs are then 'splay sorted' so that we can add and remove times from the linked list and yet somewhat swiftly figure out both how long there is until the next nearest timer expires and which timer (handle) we should take care of now\&. Of course, the upside of all this is that we get a \fC\fCcurl_multi_timeout()\fP\fP that should also work with old-style applications that use \fC\fCcurl_multi_perform()\fP\fP\&.
.PP
We created an internal 'socket to easy handles' hash table that given a socket (file descriptor) returns the easy handle that waits for action on that socket\&. This hash is made using the already existing hash code (previously only used for the DNS cache)\&.
.PP
To make libcurl able to report plain sockets in the socket callback, we had to re-organize the internals of the \fC\fCcurl_multi_fdset()\fP\fP etc so that the conversion from sockets to \fCfd_sets\fP for that function is only done in the last step before the data is returned\&. I also had to extend c-ares to get a function that can return plain sockets, as that library too returned only \fCfd_sets\fP and that is no longer good enough\&. The changes done to c-ares are available in c-ares 1\&.3\&.1 and later\&.
.PP
 
.SH "Structs in libcurl"
.PP
This section should cover 7\&.32\&.0 pretty accurately, but will make sense even for older and later versions as things don't change drastically that often\&.
.PP
 
.SS "Curl_easy"
The \fC\fBCurl_easy\fP\fP struct is the one returned to the outside in the external API as a \fCCURL *\fP\&. This is usually known as an easy handle in API documentations and examples\&.
.PP
Information and state that is related to the actual connection is in the \fCconnectdata\fP struct\&. When a transfer is about to be made, libcurl will either create a new connection or re-use an existing one\&. The particular connectdata that is used by this handle is pointed out by \fCCurl_easy->easy_conn\fP\&.
.PP
Data and information that regard this particular single transfer is put in the \fC\fBSingleRequest\fP\fP sub-struct\&.
.PP
When the \fC\fBCurl_easy\fP\fP struct is added to a multi handle, as it must be in order to do any transfer, the \fC->multi\fP member will point to the \fC\fBCurl_multi\fP\fP struct it belongs to\&. The \fC->prev\fP and \fC->next\fP members will then be used by the multi code to keep a linked list of \fC\fBCurl_easy\fP\fP structs that are added to that same multi handle\&. libcurl always uses multi so \fC->multi\fP \fIwill\fP point to a \fC\fBCurl_multi\fP\fP when a transfer is in progress\&.
.PP
\fC->mstate\fP is the multi state of this particular \fC\fBCurl_easy\fP\fP\&. When \fCmulti_runsingle()\fP is called, it will act on this handle according to which state it is in\&. The mstate is also what tells which sockets to return for a specific \fC\fBCurl_easy\fP\fP when \fC\fCcurl_multi_fdset()\fP\fP is called etc\&.
.PP
The libcurl source code generally use the name \fCdata\fP for the variable that points to the \fC\fBCurl_easy\fP\fP\&.
.PP
When doing multiplexed HTTP/2 transfers, each \fC\fBCurl_easy\fP\fP is associated with an individual stream, sharing the same connectdata struct\&. Multiplexing makes it even more important to keep things associated with the right thing!
.PP
 
.SS "connectdata"
\fBA\fP general idea in libcurl is to keep connections around in a connection 'cache' after they have been used in case they will be used again and then re-use an existing one instead of creating a new as it creates a significant performance boost\&.
.PP
Each \fCconnectdata\fP identifies a single physical connection to a server\&. If the connection can't be kept alive, the connection will be closed after use and then this struct can be removed from the cache and freed\&.
.PP
Thus, the same \fC\fBCurl_easy\fP\fP can be used multiple times and each time select another \fCconnectdata\fP struct to use for the connection\&. Keep this in mind, as it is then important to consider if options or choices are based on the connection or the \fC\fBCurl_easy\fP\fP\&.
.PP
Functions in libcurl will assume that \fCconnectdata->data\fP points to the \fC\fBCurl_easy\fP\fP that uses this connection (for the moment)\&.
.PP
As a special complexity, some protocols supported by libcurl require a special disconnect procedure that is more than just shutting down the socket\&. It can involve sending one or more commands to the server before doing so\&. Since connections are kept in the connection cache after use, the original \fC\fBCurl_easy\fP\fP may no longer be around when the time comes to shut down a particular connection\&. For this purpose, libcurl holds a special dummy \fCclosure_handle\fP \fC\fBCurl_easy\fP\fP in the \fC\fBCurl_multi\fP\fP struct to use when needed\&.
.PP
\fBFTP\fP uses two TCP connections for a typical transfer but it keeps both in this single struct and thus can be considered a single connection for most internal concerns\&.
.PP
The libcurl source code generally use the name \fCconn\fP for the variable that points to the connectdata\&.
.PP
 
.SS "Curl_multi"
Internally, the easy interface is implemented as a wrapper around multi interface functions\&. This makes everything multi interface\&.
.PP
\fC\fBCurl_multi\fP\fP is the multi handle struct exposed as \fCCURLM *\fP in external APIs\&.
.PP
This struct holds a list of \fC\fBCurl_easy\fP\fP structs that have been added to this handle with \fC\fCcurl_multi_add_handle()\fP\fP\&. The start of the list is \fC->easyp\fP and \fC->num_easy\fP is a counter of added \fC\fBCurl_easy\fP\fPs\&.
.PP
\fC->msglist\fP is a linked list of messages to send back when \fC\fCcurl_multi_info_read()\fP\fP is called\&. Basically a node is added to that list when an individual \fC\fBCurl_easy\fP\fP's transfer has completed\&.
.PP
\fC->hostcache\fP points to the name cache\&. It is a hash table for looking up name to IP\&. The nodes have a limited life time in there and this cache is meant to reduce the time for when the same name is wanted within a short period of time\&.
.PP
\fC->timetree\fP points to a tree of \fC\fBCurl_easy\fP\fPs, sorted by the remaining time until it should be checked - normally some sort of timeout\&. Each \fC\fBCurl_easy\fP\fP has one node in the tree\&.
.PP
\fC->sockhash\fP is a hash table to allow fast lookups of socket descriptor for which \fC\fBCurl_easy\fP\fP uses that descriptor\&. This is necessary for the \fCmulti_socket\fP API\&.
.PP
\fC->conn_cache\fP points to the connection cache\&. It keeps track of all connections that are kept after use\&. The cache has a maximum size\&.
.PP
\fC->closure_handle\fP is described in the \fCconnectdata\fP section\&.
.PP
The libcurl source code generally use the name \fCmulti\fP for the variable that points to the \fC\fBCurl_multi\fP\fP struct\&.
.PP
 
.SS "Curl_handler"
Each unique protocol that is supported by libcurl needs to provide at least one \fC\fBCurl_handler\fP\fP struct\&. It defines what the protocol is called and what functions the main code should call to deal with protocol specific issues\&. In general, there's a source file named \fC[protocol]\&.c\fP in which there's a \fCstruct \fBCurl_handler\fP Curl_handler_[protocol]\fP declared\&. In \fCurl\&.c\fP there's then the main array with all individual \fC\fBCurl_handler\fP\fP structs pointed to from a single array which is scanned through when a URL is given to libcurl to work with\&.
.PP
The concrete function pointer prototypes can be found in \fC\fBlib/urldata\&.h\fP\fP\&.
.PP
\fC->scheme\fP is the URL scheme name, usually spelled out in uppercase\&. That's 'HTTP' or 'FTP' etc\&. SSL versions of the protocol need their own \fC\fBCurl_handler\fP\fP setup so HTTPS separate from \fBHTTP\fP\&.
.PP
\fC->setup_connection\fP is called to allow the protocol code to allocate protocol specific data that then gets associated with that \fC\fBCurl_easy\fP\fP for the rest of this transfer\&. It gets freed again at the end of the transfer\&. It will be called before the \fCconnectdata\fP for the transfer has been selected/created\&. Most protocols will allocate its private \fCstruct [PROTOCOL]\fP here and assign \fCCurl_easy->req\&.p\&.[protocol]\fP to it\&.
.PP
\fC->connect_it\fP allows a protocol to do some specific actions after the TCP connect is done, that can still be considered part of the connection phase\&.
.PP
Some protocols will alter the \fCconnectdata->recv[]\fP and \fCconnectdata->send[]\fP function pointers in this function\&.
.PP
\fC->connecting\fP is similarly a function that keeps getting called as long as the protocol considers itself still in the connecting phase\&.
.PP
\fC->do_it\fP is the function called to issue the transfer request\&. What we call the DO action internally\&. If the DO is not enough and things need to be kept getting done for the entire DO sequence to complete, \fC->doing\fP is then usually also provided\&. Each protocol that needs to do multiple commands or similar for do/doing need to implement their own state machines (see SCP, SFTP, \fBFTP\fP)\&. Some protocols (only \fBFTP\fP and only due to historical reasons) has a separate piece of the DO state called \fCDO_MORE\fP\&.
.PP
\fC->doing\fP keeps getting called while issuing the transfer request command(s)
.PP
\fC->done\fP gets called when the transfer is complete and DONE\&. That's after the main data has been transferred\&.
.PP
\fC->do_more\fP gets called during the \fCDO_MORE\fP state\&. The \fBFTP\fP protocol uses this state when setting up the second connection\&.
.PP
\fC->proto_getsock\fP \fC->doing_getsock\fP \fC->domore_getsock\fP \fC->perform_getsock\fP Functions that return socket information\&. Which socket(s) to wait for which I/O action(s) during the particular multi state\&.
.PP
\fC->disconnect\fP is called immediately before the TCP connection is shutdown\&.
.PP
\fC->readwrite\fP gets called during transfer to allow the protocol to do extra reads/writes
.PP
\fC->attach\fP attaches a transfer to the connection\&.
.PP
\fC->defport\fP is the default report TCP or UDP port this protocol uses
.PP
\fC->protocol\fP is one or more bits in the \fCCURLPROTO_*\fP set\&. The SSL versions have their 'base' protocol set and then the SSL variation\&. Like 'HTTP|HTTPS'\&.
.PP
\fC->flags\fP is a bitmask with additional information about the protocol that will make it get treated differently by the generic engine:
.PP
.IP "\(bu" 2
\fCPROTOPT_SSL\fP - will make it connect and negotiate SSL
.IP "\(bu" 2
\fCPROTOPT_DUAL\fP - this protocol uses two connections
.IP "\(bu" 2
\fCPROTOPT_CLOSEACTION\fP - this protocol has actions to do before closing the connection\&. This flag is no longer used by code, yet still set for a bunch of protocol handlers\&.
.IP "\(bu" 2
\fCPROTOPT_DIRLOCK\fP - 'direction lock'\&. The SSH protocols set this bit to limit which 'direction' of socket actions that the main engine will concern itself with\&.
.IP "\(bu" 2
\fCPROTOPT_NONETWORK\fP - a protocol that doesn't use network (read \fCfile:\fP)
.IP "\(bu" 2
\fCPROTOPT_NEEDSPWD\fP - this protocol needs a password and will use a default one unless one is provided
.IP "\(bu" 2
\fCPROTOPT_NOURLQUERY\fP - this protocol can't handle a query part on the URL (?foo=bar)
.PP
.PP
 
.SS "conncache"
Is a hash table with connections for later re-use\&. Each \fC\fBCurl_easy\fP\fP has a pointer to its connection cache\&. Each multi handle sets up a connection cache that all added \fC\fBCurl_easy\fP\fPs share by default\&.
.PP
 
.SS "Curl_share"
The libcurl share API allocates a \fC\fBCurl_share\fP\fP struct, exposed to the external API as \fCCURLSH *\fP\&.
.PP
The idea is that the struct can have a set of its own versions of caches and pools and then by providing this struct in the \fCCURLOPT_SHARE\fP option, those specific \fC\fBCurl_easy\fP\fPs will use the caches/pools that this share handle holds\&.
.PP
Then individual \fC\fBCurl_easy\fP\fP structs can be made to share specific things that they otherwise wouldn't, such as cookies\&.
.PP
The \fC\fBCurl_share\fP\fP struct can currently hold cookies, DNS cache and the SSL session cache\&.
.PP
 
.SS "CookieInfo"
This is the main cookie struct\&. It holds all known cookies and related information\&. Each \fC\fBCurl_easy\fP\fP has its own private \fC\fBCookieInfo\fP\fP even when they are added to a multi handle\&. They can be made to share cookies by using the share API\&. 
