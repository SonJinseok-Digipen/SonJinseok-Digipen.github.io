.TH "TiXmlDeclaration" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TiXmlDeclaration
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tinyxml\&.h>\fP
.PP
Inherits \fBTiXmlNode\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTiXmlDeclaration\fP ()"
.br
.RI "Construct an empty declaration\&. "
.ti -1c
.RI "\fBTiXmlDeclaration\fP (const char *_version, const char *_encoding, const char *_standalone)"
.br
.RI "Construct\&. "
.ti -1c
.RI "\fBTiXmlDeclaration\fP (const \fBTiXmlDeclaration\fP &copy)"
.br
.ti -1c
.RI "\fBTiXmlDeclaration\fP & \fBoperator=\fP (const \fBTiXmlDeclaration\fP &copy)"
.br
.ti -1c
.RI "const char * \fBVersion\fP () const"
.br
.RI "Version\&. Will return an empty string if none was found\&. "
.ti -1c
.RI "const char * \fBEncoding\fP () const"
.br
.RI "Encoding\&. Will return an empty string if none was found\&. "
.ti -1c
.RI "const char * \fBStandalone\fP () const"
.br
.RI "Is this a standalone document? "
.ti -1c
.RI "virtual \fBTiXmlNode\fP * \fBClone\fP () const"
.br
.RI "Creates a copy of this Declaration and returns it\&. "
.ti -1c
.RI "virtual void \fBPrint\fP (FILE *cfile, int depth, TIXML_STRING *str) const"
.br
.ti -1c
.RI "virtual void \fBPrint\fP (FILE *cfile, int depth) const"
.br
.ti -1c
.RI "virtual const char * \fBParse\fP (const char *p, \fBTiXmlParsingData\fP *\fBdata\fP, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "virtual const \fBTiXmlDeclaration\fP * \fBToDeclaration\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlDeclaration\fP * \fBToDeclaration\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null not of the requested type\&. "
.ti -1c
.RI "virtual bool \fBAccept\fP (\fBTiXmlVisitor\fP *visitor) const"
.br
.in -1c

Public Member Functions inherited from \fBTiXmlNode\fP
.in +1c
.ti -1c
.RI "const char * \fBValue\fP () const"
.br
.ti -1c
.RI "const TIXML_STRING & \fBValueTStr\fP () const"
.br
.ti -1c
.RI "void \fBSetValue\fP (const char *_value)"
.br
.ti -1c
.RI "void \fBClear\fP ()"
.br
.RI "Delete all the children of this node\&. Does not affect 'this'\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBParent\fP ()"
.br
.RI "One step up the DOM\&. "
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBParent\fP () const"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBFirstChild\fP () const"
.br
.RI "The first child of this node\&. Will be null if there are no children\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBFirstChild\fP ()"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBFirstChild\fP (const char *\fBvalue\fP) const"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBFirstChild\fP (const char *_value)"
.br
.RI "The first child of this node with the matching 'value'\&. Will be null if none found\&. "
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBLastChild\fP () const"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBLastChild\fP ()"
.br
.RI "The last child of this node\&. Will be null if there are no children\&. "
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBLastChild\fP (const char *\fBvalue\fP) const"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBLastChild\fP (const char *_value)"
.br
.RI "The last child of this node matching 'value'\&. Will be null if there are no children\&. "
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBIterateChildren\fP (const \fBTiXmlNode\fP *previous) const"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBIterateChildren\fP (const \fBTiXmlNode\fP *previous)"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBIterateChildren\fP (const char *\fBvalue\fP, const \fBTiXmlNode\fP *previous) const"
.br
.RI "This flavor of IterateChildren searches for children with a particular 'value'\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBIterateChildren\fP (const char *_value, const \fBTiXmlNode\fP *previous)"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBInsertEndChild\fP (const \fBTiXmlNode\fP &addThis)"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBLinkEndChild\fP (\fBTiXmlNode\fP *addThis)"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBInsertBeforeChild\fP (\fBTiXmlNode\fP *beforeThis, const \fBTiXmlNode\fP &addThis)"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBInsertAfterChild\fP (\fBTiXmlNode\fP *afterThis, const \fBTiXmlNode\fP &addThis)"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBReplaceChild\fP (\fBTiXmlNode\fP *replaceThis, const \fBTiXmlNode\fP &withThis)"
.br
.ti -1c
.RI "bool \fBRemoveChild\fP (\fBTiXmlNode\fP *removeThis)"
.br
.RI "Delete a child of this node\&. "
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBPreviousSibling\fP () const"
.br
.RI "Navigate to a sibling node\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBPreviousSibling\fP ()"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBPreviousSibling\fP (const char *) const"
.br
.RI "Navigate to a sibling node\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBPreviousSibling\fP (const char *_prev)"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBNextSibling\fP () const"
.br
.RI "Navigate to a sibling node\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBNextSibling\fP ()"
.br
.ti -1c
.RI "const \fBTiXmlNode\fP * \fBNextSibling\fP (const char *) const"
.br
.RI "Navigate to a sibling node with the given 'value'\&. "
.ti -1c
.RI "\fBTiXmlNode\fP * \fBNextSibling\fP (const char *_next)"
.br
.ti -1c
.RI "const \fBTiXmlElement\fP * \fBNextSiblingElement\fP () const"
.br
.ti -1c
.RI "\fBTiXmlElement\fP * \fBNextSiblingElement\fP ()"
.br
.ti -1c
.RI "const \fBTiXmlElement\fP * \fBNextSiblingElement\fP (const char *) const"
.br
.ti -1c
.RI "\fBTiXmlElement\fP * \fBNextSiblingElement\fP (const char *_next)"
.br
.ti -1c
.RI "const \fBTiXmlElement\fP * \fBFirstChildElement\fP () const"
.br
.RI "Convenience function to get through elements\&. "
.ti -1c
.RI "\fBTiXmlElement\fP * \fBFirstChildElement\fP ()"
.br
.ti -1c
.RI "const \fBTiXmlElement\fP * \fBFirstChildElement\fP (const char *_value) const"
.br
.RI "Convenience function to get through elements\&. "
.ti -1c
.RI "\fBTiXmlElement\fP * \fBFirstChildElement\fP (const char *_value)"
.br
.ti -1c
.RI "int \fBType\fP () const"
.br
.ti -1c
.RI "const \fBTiXmlDocument\fP * \fBGetDocument\fP () const"
.br
.ti -1c
.RI "\fBTiXmlDocument\fP * \fBGetDocument\fP ()"
.br
.ti -1c
.RI "bool \fBNoChildren\fP () const"
.br
.RI "Returns true if this node has no children\&. "
.ti -1c
.RI "virtual const \fBTiXmlDocument\fP * \fBToDocument\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual const \fBTiXmlElement\fP * \fBToElement\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual const \fBTiXmlComment\fP * \fBToComment\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual const \fBTiXmlUnknown\fP * \fBToUnknown\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual const \fBTiXmlText\fP * \fBToText\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual const \fBTiXmlDeclaration\fP * \fBToDeclaration\fP () const"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlDocument\fP * \fBToDocument\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlElement\fP * \fBToElement\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlComment\fP * \fBToComment\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlUnknown\fP * \fBToUnknown\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlText\fP * \fBToText\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlDeclaration\fP * \fBToDeclaration\fP ()"
.br
.RI "Cast to a more defined type\&. Will return null if not of the requested type\&. "
.ti -1c
.RI "virtual \fBTiXmlNode\fP * \fBClone\fP () const =0"
.br
.ti -1c
.RI "virtual bool \fBAccept\fP (\fBTiXmlVisitor\fP *visitor) const =0"
.br
.in -1c

Public Member Functions inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "virtual void \fBPrint\fP (FILE *cfile, int depth) const =0"
.br
.ti -1c
.RI "int \fBRow\fP () const"
.br
.ti -1c
.RI "int \fBColumn\fP () const"
.br
.RI "See \fBRow()\fP "
.ti -1c
.RI "void \fBSetUserData\fP (void *user)"
.br
.RI "Set a pointer to arbitrary user data\&. "
.ti -1c
.RI "void * \fBGetUserData\fP ()"
.br
.RI "Get a pointer to arbitrary user data\&. "
.ti -1c
.RI "const void * \fBGetUserData\fP () const"
.br
.RI "Get a pointer to arbitrary user data\&. "
.ti -1c
.RI "virtual const char * \fBParse\fP (const char *p, \fBTiXmlParsingData\fP *\fBdata\fP, TiXmlEncoding encoding)=0"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBCopyTo\fP (\fBTiXmlDeclaration\fP *target) const"
.br
.in -1c

Protected Member Functions inherited from \fBTiXmlNode\fP
.in +1c
.ti -1c
.RI "\fBTiXmlNode\fP (\fBNodeType\fP _type)"
.br
.ti -1c
.RI "void \fBCopyTo\fP (\fBTiXmlNode\fP *target) const"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBIdentify\fP (const char *start, TiXmlEncoding encoding)"
.br
.in -1c
.SS "Additional Inherited Members"


Public Types inherited from \fBTiXmlNode\fP
.in +1c
.ti -1c
.RI "enum \fBNodeType\fP { \fBTINYXML_DOCUMENT\fP, \fBTINYXML_ELEMENT\fP, \fBTINYXML_COMMENT\fP, \fBTINYXML_UNKNOWN\fP, \fBTINYXML_TEXT\fP, \fBTINYXML_DECLARATION\fP, \fBTINYXML_TYPECOUNT\fP }"
.br
.in -1c

Public Types inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "enum { \fBTIXML_NO_ERROR\fP = 0, \fBTIXML_ERROR\fP, \fBTIXML_ERROR_OPENING_FILE\fP, \fBTIXML_ERROR_PARSING_ELEMENT\fP, \fBTIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME\fP, \fBTIXML_ERROR_READING_ELEMENT_VALUE\fP, \fBTIXML_ERROR_READING_ATTRIBUTES\fP, \fBTIXML_ERROR_PARSING_EMPTY\fP, \fBTIXML_ERROR_READING_END_TAG\fP, \fBTIXML_ERROR_PARSING_UNKNOWN\fP, \fBTIXML_ERROR_PARSING_COMMENT\fP, \fBTIXML_ERROR_PARSING_DECLARATION\fP, \fBTIXML_ERROR_DOCUMENT_EMPTY\fP, \fBTIXML_ERROR_EMBEDDED_NULL\fP, \fBTIXML_ERROR_PARSING_CDATA\fP, \fBTIXML_ERROR_DOCUMENT_TOP_ONLY\fP, \fBTIXML_ERROR_STRING_COUNT\fP }"
.br
.in -1c

Static Public Member Functions inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "static void \fBSetCondenseWhiteSpace\fP (bool condense)"
.br
.ti -1c
.RI "static bool \fBIsWhiteSpaceCondensed\fP ()"
.br
.RI "Return the current white space setting\&. "
.ti -1c
.RI "static void \fBEncodeString\fP (const TIXML_STRING &str, TIXML_STRING *out)"
.br
.in -1c

Static Public Attributes inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "static const int \fButf8ByteTable\fP [256]"
.br
.in -1c

Static Protected Member Functions inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "static const char * \fBSkipWhiteSpace\fP (const char *, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static bool \fBIsWhiteSpace\fP (char c)"
.br
.ti -1c
.RI "static bool \fBIsWhiteSpace\fP (int c)"
.br
.ti -1c
.RI "static const char * \fBReadName\fP (const char *p, TIXML_STRING *name, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static const char * \fBReadText\fP (const char *in, TIXML_STRING *text, bool ignoreWhiteSpace, const char *endTag, bool ignoreCase, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static const char * \fBGetEntity\fP (const char *in, char *\fBvalue\fP, int *length, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static const char * \fBGetChar\fP (const char *p, char *_value, int *length, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static bool \fBStringEqual\fP (const char *p, const char *endTag, bool ignoreCase, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static int \fBIsAlpha\fP (unsigned char anyByte, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static int \fBIsAlphaNum\fP (unsigned char anyByte, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static int \fBToLower\fP (int v, TiXmlEncoding encoding)"
.br
.ti -1c
.RI "static void \fBConvertUTF32ToUTF8\fP (unsigned long \fBinput\fP, char *output, int *length)"
.br
.in -1c

Protected Attributes inherited from \fBTiXmlNode\fP
.in +1c
.ti -1c
.RI "\fBTiXmlNode\fP * \fBparent\fP"
.br
.ti -1c
.RI "\fBNodeType\fP \fBtype\fP"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBfirstChild\fP"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBlastChild\fP"
.br
.ti -1c
.RI "TIXML_STRING \fBvalue\fP"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBprev\fP"
.br
.ti -1c
.RI "\fBTiXmlNode\fP * \fBnext\fP"
.br
.in -1c

Protected Attributes inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "\fBTiXmlCursor\fP \fBlocation\fP"
.br
.ti -1c
.RI "void * \fBuserData\fP"
.br
.RI "Field containing a generic user pointer\&. "
.in -1c

Static Protected Attributes inherited from \fBTiXmlBase\fP
.in +1c
.ti -1c
.RI "static const char * \fBerrorString\fP [TIXML_ERROR_STRING_COUNT]"
.br
.in -1c
.SH "Detailed Description"
.PP 
In correct XML the declaration is the first entry in the file\&. 
.PP
.nf
            <?xml version='1\&.0' standalone='yes'?>
.fi
.PP
.PP
TinyXml will happily read or write files without a declaration, however\&. There are 3 possible attributes to the declaration: version, encoding, and standalone\&.
.PP
Note: In this version of the code, the attributes are handled as special cases, not generic attributes, simply because there can only be at most 3 and they are always the same\&. 
.SH "Member Function Documentation"
.PP 
.SS "bool TiXmlDeclaration::Accept (\fBTiXmlVisitor\fP * visitor) const\fC [virtual]\fP"
Walk the XML tree visiting this node and all of its children\&. 
.PP
Implements \fBTiXmlNode\fP\&.
.SS "\fBTiXmlNode\fP * TiXmlDeclaration::Clone () const\fC [virtual]\fP"

.PP
Creates a copy of this Declaration and returns it\&. 
.PP
Implements \fBTiXmlNode\fP\&.
.SS "const char * TiXmlDeclaration::Parse (const char * p, \fBTiXmlParsingData\fP * data, TiXmlEncoding encoding)\fC [virtual]\fP"

.PP
Implements \fBTiXmlBase\fP\&.
.SS "virtual void TiXmlDeclaration::Print (FILE * cfile, int depth) const\fC [inline]\fP, \fC [virtual]\fP"
All TinyXml classes can print themselves to a filestream or the string class (\fBTiXmlString\fP in non-STL mode, std::string in STL mode\&.) Either or both cfile and str can be null\&.
.PP
This is a formatted print, and will insert tabs and newlines\&.
.PP
(For an unformatted stream, use the << operator\&.) 
.PP
Implements \fBTiXmlBase\fP\&.
.SS "virtual \fBTiXmlDeclaration\fP * TiXmlDeclaration::ToDeclaration ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Cast to a more defined type\&. Will return null not of the requested type\&. 
.PP
Reimplemented from \fBTiXmlNode\fP\&.
.SS "virtual const \fBTiXmlDeclaration\fP * TiXmlDeclaration::ToDeclaration () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Cast to a more defined type\&. Will return null not of the requested type\&. 
.PP
Reimplemented from \fBTiXmlNode\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
