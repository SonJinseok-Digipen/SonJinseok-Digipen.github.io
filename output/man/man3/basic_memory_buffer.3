.TH "basic_memory_buffer< T, SIZE, Allocator >" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
basic_memory_buffer< T, SIZE, Allocator >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <format\&.h>\fP
.PP
Inherits detail::buffer< T >\&.
.SS "Public Types"

.in +1c
.ti -1c
.RI "using \fBvalue_type\fP = T"
.br
.ti -1c
.RI "using \fBconst_reference\fP = const T &"
.br
.ti -1c
.RI "using \fBvalue_type\fP = T"
.br
.ti -1c
.RI "using \fBconst_reference\fP = const T &"
.br
.ti -1c
.RI "using \fBvalue_type\fP = T"
.br
.ti -1c
.RI "using \fBconst_reference\fP = const T &"
.br
.ti -1c
.RI "using \fBvalue_type\fP = T"
.br
.ti -1c
.RI "using \fBconst_reference\fP = const T &"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (const Allocator &alloc=Allocator())"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (\fBbasic_memory_buffer\fP &&other) noexcept"
.br
.ti -1c
.RI "auto \fBoperator=\fP (\fBbasic_memory_buffer\fP &&other) noexcept \-> \fBbasic_memory_buffer\fP &"
.br
.ti -1c
.RI "auto \fBget_allocator\fP () const \-> Allocator"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBresize\fP (size_t count)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_capacity)"
.br
.ti -1c
.RI "template<typename ContiguousRange > void \fBappend\fP (const ContiguousRange &range)"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (const Allocator &alloc=Allocator())"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (\fBbasic_memory_buffer\fP &&other) noexcept"
.br
.ti -1c
.RI "auto \fBoperator=\fP (\fBbasic_memory_buffer\fP &&other) noexcept \-> \fBbasic_memory_buffer\fP &"
.br
.ti -1c
.RI "auto \fBget_allocator\fP () const \-> Allocator"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBresize\fP (size_t count)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_capacity)"
.br
.ti -1c
.RI "template<typename ContiguousRange > void \fBappend\fP (const ContiguousRange &range)"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (const Allocator &alloc=Allocator())"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (\fBbasic_memory_buffer\fP &&other) noexcept"
.br
.ti -1c
.RI "auto \fBoperator=\fP (\fBbasic_memory_buffer\fP &&other) noexcept \-> \fBbasic_memory_buffer\fP &"
.br
.ti -1c
.RI "auto \fBget_allocator\fP () const \-> Allocator"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBresize\fP (size_t count)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_capacity)"
.br
.ti -1c
.RI "template<typename ContiguousRange > void \fBappend\fP (const ContiguousRange &range)"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (const Allocator &alloc=Allocator())"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP (\fBbasic_memory_buffer\fP &&other) noexcept"
.br
.ti -1c
.RI "auto \fBoperator=\fP (\fBbasic_memory_buffer\fP &&other) noexcept \-> \fBbasic_memory_buffer\fP &"
.br
.ti -1c
.RI "auto \fBget_allocator\fP () const \-> Allocator"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBresize\fP (size_t count)"
.br
.ti -1c
.RI "void \fBreserve\fP (size_t new_capacity)"
.br
.ti -1c
.RI "template<typename ContiguousRange > void \fBappend\fP (const ContiguousRange &range)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBgrow\fP (size_t size) override"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBgrow\fP (size_t size) override"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBgrow\fP (size_t size) override"
.br
.ti -1c
.RI "FMT_CONSTEXPR20 void \fBgrow\fP (size_t size) override"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T, size_t SIZE = inline_buffer_size, typename Allocator = std::allocator<T>>
.br
class basic_memory_buffer< T, SIZE, Allocator >"\\rst \fBA\fP dynamically growing memory buffer for trivially copyable/constructible types with the first \fCSIZE\fP elements stored in the object itself\&.
.PP
You can use the \fCmemory_buffer\fP type alias for \fCchar\fP instead\&.
.PP
Example**::
.PP
auto out = fmt::memory_buffer(); format_to(std::back_inserter(out), 'The answer is {}\&.', 42);
.PP
This will append the following output to the \fCout\fP object:
.PP
\&.\&. code-block:: none
.PP
The answer is 42\&.
.PP
The output can be converted to an \fCstd::string\fP with \fCto_string(out)\fP\&. \\endrst 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP< T, SIZE, Allocator >\fB::basic_memory_buffer\fP (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other)\fC [inline]\fP, \fC [noexcept]\fP"
\\rst Constructs a :class:\fCfmt::basic_memory_buffer\fP object moving the content of the other object to it\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP< T, SIZE, Allocator >\fB::basic_memory_buffer\fP (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other)\fC [inline]\fP, \fC [noexcept]\fP"
\\rst Constructs a :class:\fCfmt::basic_memory_buffer\fP object moving the content of the other object to it\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP< T, SIZE, Allocator >\fB::basic_memory_buffer\fP (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other)\fC [inline]\fP, \fC [noexcept]\fP"
\\rst Constructs a :class:\fCfmt::basic_memory_buffer\fP object moving the content of the other object to it\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 \fBbasic_memory_buffer\fP< T, SIZE, Allocator >\fB::basic_memory_buffer\fP (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other)\fC [inline]\fP, \fC [noexcept]\fP"
\\rst Constructs a :class:\fCfmt::basic_memory_buffer\fP object moving the content of the other object to it\&. \\endrst 
.SH "Member Function Documentation"
.PP 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> auto \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::operator= (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other) \-> \fBbasic_memory_buffer\fP& \fC [inline]\fP, \fC [noexcept]\fP"
\\rst Moves the content of the other \fC\fBbasic_memory_buffer\fP\fP object to this one\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> auto \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::operator= (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other) \-> \fBbasic_memory_buffer\fP& \fC [inline]\fP, \fC [noexcept]\fP"
\\rst Moves the content of the other \fC\fBbasic_memory_buffer\fP\fP object to this one\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> auto \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::operator= (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other) \-> \fBbasic_memory_buffer\fP& \fC [inline]\fP, \fC [noexcept]\fP"
\\rst Moves the content of the other \fC\fBbasic_memory_buffer\fP\fP object to this one\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> auto \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::operator= (\fBbasic_memory_buffer\fP< T, SIZE, Allocator > && other) \-> \fBbasic_memory_buffer\fP& \fC [inline]\fP, \fC [noexcept]\fP"
\\rst Moves the content of the other \fC\fBbasic_memory_buffer\fP\fP object to this one\&. \\endrst 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::reserve (size_t new_capacity)\fC [inline]\fP"
Increases the buffer capacity to \fInew_capacity\fP\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::reserve (size_t new_capacity)\fC [inline]\fP"
Increases the buffer capacity to \fInew_capacity\fP\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::reserve (size_t new_capacity)\fC [inline]\fP"
Increases the buffer capacity to \fInew_capacity\fP\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::reserve (size_t new_capacity)\fC [inline]\fP"
Increases the buffer capacity to \fInew_capacity\fP\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::resize (size_t count)\fC [inline]\fP"
Resizes the buffer to contain \fIcount\fP elements\&. If T is a POD type new elements may not be initialized\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::resize (size_t count)\fC [inline]\fP"
Resizes the buffer to contain \fIcount\fP elements\&. If T is a POD type new elements may not be initialized\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::resize (size_t count)\fC [inline]\fP"
Resizes the buffer to contain \fIcount\fP elements\&. If T is a POD type new elements may not be initialized\&. 
.SS "template<typename T , size_t SIZE = inline_buffer_size, typename Allocator  = std::allocator<T>> FMT_CONSTEXPR20 void \fBbasic_memory_buffer\fP< T, SIZE, Allocator >::resize (size_t count)\fC [inline]\fP"
Resizes the buffer to contain \fIcount\fP elements\&. If T is a POD type new elements may not be initialized\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
