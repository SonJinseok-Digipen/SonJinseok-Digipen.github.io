.TH "gzifstream" 3 "Wed Feb 1 2023" "Version Version 0.0" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gzifstream \- Gzipped file input stream class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <zfstream\&.h>\fP
.PP
Inherits \fBgzfilestream_common\fP, istream, and std::istream\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBgzifstream\fP (const char *name, int io_mode=ios::in)"
.br
.ti -1c
.RI "\fBgzifstream\fP (int fd, int io_mode=ios::in)"
.br
.ti -1c
.RI "\fBgzifstream\fP (const char *name, std::ios_base::openmode mode=std::ios_base::in)"
.br
.RI "Construct stream on gzipped file to be opened\&. "
.ti -1c
.RI "\fBgzifstream\fP (int fd, std::ios_base::openmode mode=std::ios_base::in)"
.br
.RI "Construct stream on already open gzipped file\&. "
.ti -1c
.RI "\fBgzfilebuf\fP * \fBrdbuf\fP () const"
.br
.ti -1c
.RI "bool \fBis_open\fP ()"
.br
.RI "Check if file is open\&. "
.ti -1c
.RI "void \fBopen\fP (const char *name, std::ios_base::openmode mode=std::ios_base::in)"
.br
.RI "Open gzipped file\&. "
.ti -1c
.RI "void \fBattach\fP (int fd, std::ios_base::openmode mode=std::ios_base::in)"
.br
.RI "Attach to already open gzipped file\&. "
.ti -1c
.RI "void \fBclose\fP ()"
.br
.RI "Close gzipped file\&. "
.in -1c

Public Member Functions inherited from \fBgzfilestream_common\fP
.in +1c
.ti -1c
.RI "void \fBattach\fP (int fd, int io_mode)"
.br
.ti -1c
.RI "void \fBopen\fP (const char *name, int io_mode)"
.br
.ti -1c
.RI "void \fBclose\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Gzipped file input stream class\&. 

This class implements ifstream for gzipped files\&. Seeking and putback is not supported yet\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "gzifstream::gzifstream (const char * name, std::ios_base::openmode mode = \fCstd::ios_base::in\fP)\fC [explicit]\fP"

.PP
Construct stream on gzipped file to be opened\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP File name\&. 
.br
\fImode\fP Open mode flags (forced to contain ios::in)\&. 
.RE
.PP

.SS "gzifstream::gzifstream (int fd, std::ios_base::openmode mode = \fCstd::ios_base::in\fP)\fC [explicit]\fP"

.PP
Construct stream on already open gzipped file\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP File descriptor\&. 
.br
\fImode\fP Open mode flags (forced to contain ios::in)\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void gzifstream::attach (int fd, std::ios_base::openmode mode = \fCstd::ios_base::in\fP)"

.PP
Attach to already open gzipped file\&. 
.PP
\fBParameters\fP
.RS 4
\fIfd\fP File descriptor\&. 
.br
\fImode\fP Open mode flags (forced to contain ios::in)\&.
.RE
.PP
Stream will be in state good() if attach succeeded; otherwise in state fail()\&. 
.SS "void gzifstream::close ()"

.PP
Close gzipped file\&. Stream will be in state fail() if close failed\&. 
.SS "bool gzifstream::is_open ()\fC [inline]\fP"

.PP
Check if file is open\&. 
.PP
\fBReturns\fP
.RS 4
True if file is open\&. 
.RE
.PP

.SS "void gzifstream::open (const char * name, std::ios_base::openmode mode = \fCstd::ios_base::in\fP)"

.PP
Open gzipped file\&. 
.PP
\fBParameters\fP
.RS 4
\fIname\fP File name\&. 
.br
\fImode\fP Open mode flags (forced to contain ios::in)\&.
.RE
.PP
Stream will be in state good() if file opens successfully; otherwise in state fail()\&. This differs from the behavior of ifstream, which never sets the state to good() and therefore won't allow you to reuse the stream for a second file unless you manually clear() the state\&. The choice is a matter of convenience\&. 
.SS "\fBgzfilebuf\fP * gzifstream::rdbuf () const\fC [inline]\fP"
Obtain underlying stream buffer\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
