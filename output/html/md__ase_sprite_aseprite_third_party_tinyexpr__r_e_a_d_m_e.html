<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project<span id="projectnumber">&#160;Version 0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">README </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/codeplea/tinyexpr"><img src="https://travis-ci.org/codeplea/tinyexpr.svg?branch=master" alt="Build Status" style="pointer-events: none;" class="inline"/></a></p>
<p><img src="https://codeplea.com/public/content/tinyexpr_logo.png" alt="TinyExpr logo" align="right" class="inline"/></p>
<h1><a class="anchor" id="autotoc_md1826"></a>
TinyExpr</h1>
<p>TinyExpr is a very small recursive descent parser and evaluation engine for math expressions. It's handy when you want to add the ability to evaluation math expressions at runtime without adding a bunch of cruft to you project.</p>
<p>In addition to the standard math operators and precedence, TinyExpr also supports the standard C math functions and runtime binding of variables.</p>
<h2><a class="anchor" id="autotoc_md1827"></a>
Features</h2>
<ul>
<li><b>ANSI C with no dependencies</b>.</li>
<li>Single source file and header file.</li>
<li>Simple and fast.</li>
<li>Implements standard operators precedence.</li>
<li>Exposes standard C math functions (sin, sqrt, ln, etc.).</li>
<li>Can add custom functions and variables easily.</li>
<li>Can bind variables at eval-time.</li>
<li>Released under the zlib license - free for nearly any use.</li>
<li>Easy to use and integrate with your code</li>
<li>Thread-safe, provided that your <em>malloc</em> is.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1828"></a>
Building</h2>
<p>TinyExpr is self-contained in two files: <code>tinyexpr.c</code> and <code><a class="el" href="tinyexpr_8h_source.html">tinyexpr.h</a></code>. To use TinyExpr, simply add those two files to your project.</p>
<h2><a class="anchor" id="autotoc_md1829"></a>
Short Example</h2>
<p>Here is a minimal example to evaluate an expression at runtime.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tinyexpr.h&quot;</span></div>
<div class="line">printf(<span class="stringliteral">&quot;%f\n&quot;</span>, te_interp(<span class="stringliteral">&quot;5*5&quot;</span>, 0)); <span class="comment">/* Prints 25. */</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1830"></a>
Usage</h2>
<p>TinyExpr defines only four functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> te_interp(<span class="keyword">const</span> <span class="keywordtype">char</span> *expression, <span class="keywordtype">int</span> *error);</div>
<div class="line"><a class="code hl_struct" href="structte__expr.html">te_expr</a> *te_compile(<span class="keyword">const</span> <span class="keywordtype">char</span> *expression, <span class="keyword">const</span> <a class="code hl_struct" href="structte__variable.html">te_variable</a> *variables, <span class="keywordtype">int</span> var_count, <span class="keywordtype">int</span> *error);</div>
<div class="line"><span class="keywordtype">double</span> te_eval(<span class="keyword">const</span> <a class="code hl_struct" href="structte__expr.html">te_expr</a> *expr);</div>
<div class="line"><span class="keywordtype">void</span> te_free(<a class="code hl_struct" href="structte__expr.html">te_expr</a> *expr);</div>
<div class="ttc" id="astructte__expr_html"><div class="ttname"><a href="structte__expr.html">te_expr</a></div><div class="ttdef"><b>Definition:</b> tinyexpr.h:35</div></div>
<div class="ttc" id="astructte__variable_html"><div class="ttname"><a href="structte__variable.html">te_variable</a></div><div class="ttdef"><b>Definition:</b> tinyexpr.h:54</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1831"></a>
te_interp</h2>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> te_interp(<span class="keyword">const</span> <span class="keywordtype">char</span> *expression, <span class="keywordtype">int</span> *error);</div>
</div><!-- fragment --><p><code>te_interp()</code> takes an expression and immediately returns the result of it. If there is a parse error, <code>te_interp()</code> returns NaN.</p>
<p>If the <code>error</code> pointer argument is not 0, then <code>te_interp()</code> will set <code>*error</code> to the position of the parse error on failure, and set <code>*error</code> to 0 on success.</p>
<p><b>example usage:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> error;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> <a class="code hl_struct" href="structa.html">a</a> = te_interp(<span class="stringliteral">&quot;(5+5)&quot;</span>, 0); <span class="comment">/* Returns 10. */</span></div>
<div class="line"><span class="keywordtype">double</span> b = te_interp(<span class="stringliteral">&quot;(5+5)&quot;</span>, &amp;error); <span class="comment">/* Returns 10, error is set to 0. */</span></div>
<div class="line"><span class="keywordtype">double</span> c = te_interp(<span class="stringliteral">&quot;(5+5&quot;</span>, &amp;error); <span class="comment">/* Returns NaN, error is set to 4. */</span></div>
<div class="ttc" id="astructa_html"><div class="ttname"><a href="structa.html">a</a></div><div class="ttdef"><b>Definition:</b> unit1323.c:36</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1832"></a>
te_compile, te_eval, te_free</h2>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structte__expr.html">te_expr</a> *te_compile(<span class="keyword">const</span> <span class="keywordtype">char</span> *expression, <span class="keyword">const</span> <a class="code hl_struct" href="structte__variable.html">te_variable</a> *lookup, <span class="keywordtype">int</span> lookup_len, <span class="keywordtype">int</span> *error);</div>
<div class="line"><span class="keywordtype">double</span> te_eval(<span class="keyword">const</span> <a class="code hl_struct" href="structte__expr.html">te_expr</a> *n);</div>
<div class="line"><span class="keywordtype">void</span> te_free(<a class="code hl_struct" href="structte__expr.html">te_expr</a> *n);</div>
</div><!-- fragment --><p>Give <code>te_compile()</code> an expression with unbound variables and a list of variable names and pointers. <code>te_compile()</code> will return a <code>te_expr*</code> which can be evaluated later using <code>te_eval()</code>. On failure, <code>te_compile()</code> will return 0 and optionally set the passed in <code>*error</code> to the location of the parse error.</p>
<p>You may also compile expressions without variables by passing <code>te_compile()</code>'s second and thrid arguments as 0.</p>
<p>Give <code>te_eval()</code> a <code>te_expr*</code> from <code>te_compile()</code>. <code>te_eval()</code> will evaluate the expression using the current variable values.</p>
<p>After you're finished, make sure to call <code>te_free()</code>.</p>
<p><b>example usage:</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> x, y;</div>
<div class="line"><span class="comment">/* Store variable names and pointers. */</span></div>
<div class="line"><a class="code hl_struct" href="structte__variable.html">te_variable</a> vars[] = {{<span class="stringliteral">&quot;x&quot;</span>, &amp;x}, {<span class="stringliteral">&quot;y&quot;</span>, &amp;y}};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> err;</div>
<div class="line"><span class="comment">/* Compile the expression with variables. */</span></div>
<div class="line"><a class="code hl_struct" href="structte__expr.html">te_expr</a> *expr = te_compile(<span class="stringliteral">&quot;sqrt(x^2+y^2)&quot;</span>, vars, 2, &amp;err);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (expr) {</div>
<div class="line">    x = 3; y = 4;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h1 = te_eval(expr); <span class="comment">/* Returns 5. */</span></div>
<div class="line"> </div>
<div class="line">    x = 5; y = 12;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> h2 = te_eval(expr); <span class="comment">/* Returns 13. */</span></div>
<div class="line"> </div>
<div class="line">    te_free(expr);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    printf(<span class="stringliteral">&quot;Parse error at %d\n&quot;</span>, err);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1833"></a>
Longer Example</h2>
<p>Here is a complete example that will evaluate an expression passed in from the command line. It also does error checking and binds the variables <code>x</code> and <code>y</code> to <em>3</em> and <em>4</em>, respectively.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tinyexpr.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Usage: example2 \&quot;expression\&quot;\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *expression = argv[1];</div>
<div class="line">    printf(<span class="stringliteral">&quot;Evaluating:\n\t%s\n&quot;</span>, expression);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* This shows an example where the variables</span></div>
<div class="line"><span class="comment">     * x and y are bound at eval-time. */</span></div>
<div class="line">    <span class="keywordtype">double</span> x, y;</div>
<div class="line">    <a class="code hl_struct" href="structte__variable.html">te_variable</a> vars[] = {{<span class="stringliteral">&quot;x&quot;</span>, &amp;x}, {<span class="stringliteral">&quot;y&quot;</span>, &amp;y}};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* This will compile the expression and check for errors. */</span></div>
<div class="line">    <span class="keywordtype">int</span> err;</div>
<div class="line">    <a class="code hl_struct" href="structte__expr.html">te_expr</a> *n = te_compile(expression, vars, 2, &amp;err);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (n) {</div>
<div class="line">        <span class="comment">/* The variables can be changed here, and eval can be called as many</span></div>
<div class="line"><span class="comment">         * times as you like. This is fairly efficient because the parsing has</span></div>
<div class="line"><span class="comment">         * already been done. */</span></div>
<div class="line">        x = 3; y = 4;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> r = te_eval(n); printf(<span class="stringliteral">&quot;Result:\n\t%f\n&quot;</span>, r);</div>
<div class="line">        te_free(n);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">/* Show the user where the error is at. */</span></div>
<div class="line">        printf(<span class="stringliteral">&quot;\t%*s^\nError near here&quot;</span>, err-1, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This produces the output: </p><pre class="fragment">$ example2 "sqrt(x^2+y2)"
    Evaluating:
            sqrt(x^2+y2)
                      ^
    Error near here


$ example2 "sqrt(x^2+y^2)"
    Evaluating:
            sqrt(x^2+y^2)
    Result:
            5.000000
</pre><h2><a class="anchor" id="autotoc_md1834"></a>
Binding to Custom Functions</h2>
<p>TinyExpr can also call to custom functions implemented in C. Here is a short example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> my_sum(<span class="keywordtype">double</span> <a class="code hl_struct" href="structa.html">a</a>, <span class="keywordtype">double</span> b) {</div>
<div class="line">    <span class="comment">/* Example C function that adds two numbers together. */</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_struct" href="structa.html">a</a> + b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structte__variable.html">te_variable</a> vars[] = {</div>
<div class="line">    {<span class="stringliteral">&quot;mysum&quot;</span>, my_sum, TE_FUNCTION2} <span class="comment">/* TE_FUNCTION2 used because my_sum takes two arguments. */</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="structte__expr.html">te_expr</a> *n = te_compile(<span class="stringliteral">&quot;mysum(5, 6)&quot;</span>, vars, 1, 0);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1835"></a>
How it works</h2>
<p><code>te_compile()</code> uses a simple recursive descent parser to compile your expression into a syntax tree. For example, the expression <code>"sin x + 1/4"</code> parses as:</p>
<p><img src="doc/e1.png?raw=true" alt="example syntax tree" class="inline"/></p>
<p><code>te_compile()</code> also automatically prunes constant branches. In this example, the compiled expression returned by <code>te_compile()</code> would become:</p>
<p><img src="doc/e2.png?raw=true" alt="example syntax tree" class="inline"/></p>
<p><code>te_eval()</code> will automatically load in any variables by their pointer, and then evaluate and return the result of the expression.</p>
<p><code>te_free()</code> should always be called when you're done with the compiled expression.</p>
<h2><a class="anchor" id="autotoc_md1836"></a>
Speed</h2>
<p>TinyExpr is pretty fast compared to C when the expression is short, when the expression does hard calculations (e.g. exponentiation), and when some of the work can be simplified by <code>te_compile()</code>. TinyExpr is slow compared to C when the expression is long and involves only basic arithmetic.</p>
<p>Here is some example performance numbers taken from the included <b>benchmark.c</b> program:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Expression   </th><th class="markdownTableHeadRight">te_eval time   </th><th class="markdownTableHeadRight">native C time   </th><th class="markdownTableHeadRight">slowdown    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">sqrt(a^1.5+a^2.5)   </td><td class="markdownTableBodyRight">15,641 ms   </td><td class="markdownTableBodyRight">14,478 ms   </td><td class="markdownTableBodyRight">8% slower    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">a+5   </td><td class="markdownTableBodyRight">765 ms   </td><td class="markdownTableBodyRight">563 ms   </td><td class="markdownTableBodyRight">36% slower    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">a+(5*2)   </td><td class="markdownTableBodyRight">765 ms   </td><td class="markdownTableBodyRight">563 ms   </td><td class="markdownTableBodyRight">36% slower    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">(a+5)*2   </td><td class="markdownTableBodyRight">1422 ms   </td><td class="markdownTableBodyRight">563 ms   </td><td class="markdownTableBodyRight">153% slower    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">(1/(a+1)+2/(a+2)+3/(a+3))   </td><td class="markdownTableBodyRight">5,516 ms   </td><td class="markdownTableBodyRight">1,266 ms   </td><td class="markdownTableBodyRight">336% slower   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1837"></a>
Grammar</h2>
<p>TinyExpr parses the following grammar: </p><pre class="fragment">&lt;list&gt;      =    &lt;expr&gt; {"," &lt;expr&gt;}
&lt;expr&gt;      =    &lt;term&gt; {("+" | "-") &lt;term&gt;}
&lt;term&gt;      =    &lt;factor&gt; {("*" | "/" | "%") &lt;factor&gt;}
&lt;factor&gt;    =    &lt;power&gt; {"^" &lt;power&gt;}
&lt;power&gt;     =    {("-" | "+")} &lt;base&gt;
&lt;base&gt;      =    &lt;constant&gt;
               | &lt;variable&gt;
               | &lt;function-0&gt; {"(" ")"}
               | &lt;function-1&gt; &lt;power&gt;
               | &lt;function-X&gt; "(" &lt;expr&gt; {"," &lt;expr&gt;} ")"
               | "(" &lt;list&gt; ")"
</pre><p> In addition, whitespace between tokens is ignored.</p>
<p>Valid variable names consist of a lower case letter followed by any combination of: lower case letters <em>a</em> through <em>z</em>, the digits <em>0</em> through <em>9</em>, and underscore. Constants can be integers, decimal numbers, or in scientific notation (e.g. <em>1e3</em> for <em>1000</em>). <a class="el" href="class_a.html">A</a> leading zero is not required (e.g. *.5* for <em>0.5</em>)</p>
<h2><a class="anchor" id="autotoc_md1838"></a>
Functions supported</h2>
<p>TinyExpr supports addition (+), subtraction/negation (-), multiplication (*), division (/), exponentiation (^) and modulus (%) with the normal operator precedence (the one exception being that exponentiation is evaluated left-to-right, but this can be changed - see below).</p>
<p>The following C math functions are also supported:</p>
<ul>
<li>abs (calls to <em>fabs</em>), acos, asin, atan, atan2, ceil, cos, cosh, exp, floor, ln (calls to <em>log</em>), log (calls to <em>log10</em> by default, see below), log10, pow, sin, sinh, sqrt, tan, tanh</li>
</ul>
<p>The following functions are also built-in and provided by TinyExpr:</p>
<ul>
<li>fac (factorials e.g. <code>fac 5</code> == 120)</li>
<li>ncr (combinations e.g. <code>ncr(6,2)</code> == 15)</li>
<li>npr (permutations e.g. <code>npr(6,2)</code> == 30)</li>
</ul>
<p>Also, the following constants are available:</p>
<ul>
<li><code>pi</code>, <code>e</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md1839"></a>
Compile-time options</h2>
<p>By default, TinyExpr does exponentiation from left to right. For example:</p>
<p><code>a^b^c == (a^b)^c</code> and <code>-a^b == (-a)^b</code></p>
<p>This is by design. It's the way that spreadsheets do it (e.g. Excel, Google Sheets).</p>
<p>If you would rather have exponentiation work from right to left, you need to define <code>TE_POW_FROM_RIGHT</code> when compiling <code>tinyexpr.c</code>. There is a commented-out define near the top of that file. With this option enabled, the behaviour is:</p>
<p><code>a^b^c == a^(b^c)</code> and <code>-a^b == -(a^b)</code></p>
<p>That will match how many scripting languages do it (e.g. Python, Ruby).</p>
<p>Also, if you'd like <code>log</code> to default to the natural log instead of <code>log10</code>, then you can define <code>TE_NAT_LOG</code>.</p>
<h2><a class="anchor" id="autotoc_md1840"></a>
Hints</h2>
<ul>
<li>All functions/types start with the letters <em>te</em>.</li>
<li>To allow constant optimization, surround constant expressions in parentheses. For example "x+(1+5)" will evaluate the "(1+5)" expression at compile time and compile the entire expression as "x+6", saving a runtime calculation. The parentheses are important, because TinyExpr will not change the order of evaluation. If you instead compiled "x+1+5" TinyExpr will insist that "1" is added to "x" first, and "5" is added the result second. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
