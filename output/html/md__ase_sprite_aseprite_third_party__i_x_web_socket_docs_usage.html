<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Examples</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project<span id="projectnumber">&#160;Version 0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Examples </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a href="https://github.com/machinezone/IXWebSocket/tree/master/ws"><em>ws</em></a> folder countains many interactive programs for chat, <a href="https://github.com/machinezone/IXWebSocket/blob/master/ws/ws_send.cpp">file transfers</a>, <a href="https://github.com/machinezone/IXWebSocket/blob/master/ws/ws_http_client.cpp">curl like</a> http clients, demonstrating client and server usage.</p>
<h1><a class="anchor" id="autotoc_md1740"></a>
Windows note</h1>
<p>To use the network system on Windows, you need to initialize it once with <em>WSAStartup()</em> and clean it up with <em>WSACleanup()</em>. We have helpers for that which you can use, see below. This init would typically take place in your main function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXNetSystem.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    ix::initNetSystem();</div>
<div class="line"> </div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    ix::uninitNetSystem();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1741"></a>
WebSocket client API</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXWebSocket.h&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Our websocket object</span></div>
<div class="line">ix::WebSocket webSocket;</div>
<div class="line"> </div>
<div class="line">std::string url(<span class="stringliteral">&quot;ws://localhost:8080/&quot;</span>);</div>
<div class="line">webSocket.setUrl(url);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Optional heart beat, sent every 45 seconds when there is not any traffic</span></div>
<div class="line"><span class="comment">// to make sure that load balancers do not kill an idle connection.</span></div>
<div class="line">webSocket.setPingInterval(45);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Per message deflate connection is enabled by default. You can tweak its parameters or disable it</span></div>
<div class="line">webSocket.disablePerMessageDeflate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Setup a callback to be fired when a message or an event (open, close, error) is received</span></div>
<div class="line">webSocket.setOnMessageCallback([](<span class="keyword">const</span> ix::WebSocketMessagePtr&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Message)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; msg-&gt;str &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now that our callback is setup, we can start our background thread and receive messages</span></div>
<div class="line">webSocket.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a message to the server (default to TEXT mode)</span></div>
<div class="line">webSocket.send(<span class="stringliteral">&quot;hello world&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The message can be sent in BINARY mode (useful if you send MsgPack data for example)</span></div>
<div class="line">webSocket.sendBinary(<span class="stringliteral">&quot;some serialized binary data&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... finally ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop the connection</span></div>
<div class="line">webSocket.stop()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1742"></a>
Sending messages</h2>
<p><code>WebSocketSendInfo result = websocket.send("foo")</code> will send a message.</p>
<p>If the connection was closed, sending will fail, and the success field of the result object will be set to false. There could also be a compression error in which case the compressError field will be set to true. The payloadSize field and wireSize fields will tell you respectively how much bytes the message weight, and how many bytes were sent on the wire (potentially compressed + counting the message header (a few bytes).</p>
<p>There is an optional progress callback that can be passed in as the second argument. If a message is large it will be fragmented into chunks which will be sent independantly. Everytime the we can write a fragment into the OS network cache, the callback will be invoked. If a user wants to cancel a slow send, false should be returned from within the callback.</p>
<p>Here is an example code snippet copied from the ws send sub-command. Each fragment weights 32K, so the total integer is the wireSize divided by 32K. As an example if you are sending 32M of data, uncompressed, total will be 1000. current will be set to 0 for the first fragment, then 1, 2 etc...</p>
<div class="fragment"><div class="line">auto result =</div>
<div class="line">    _webSocket.sendBinary(serializedMsg, [this, throttle](int current, int total) -&gt; bool {</div>
<div class="line">        spdlog::info(&quot;ws_send: Step {} out of {}&quot;, current + 1, total);</div>
<div class="line"> </div>
<div class="line">        if (throttle)</div>
<div class="line">        {</div>
<div class="line">            std::chrono::duration&lt;double, std::milli&gt; duration(10);</div>
<div class="line">            std::this_thread::sleep_for(duration);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        return _connected;</div>
<div class="line">    });</div>
</div><!-- fragment --><p>The <code>send()</code> and <code>sendText()</code> methods check that the string contains only valid UTF-8 characters. If you know that the string is a valid UTF-8 string you can skip that step and use the <code>sendUtf8Text</code> method instead.</p>
<p>With the IXWebSocketSendData overloads of <code>sendUtf8Text</code> and <code>sendBinary</code> it is possible to not only send std::string but also <code>std::vector&lt;char&gt;</code>, <code>std::vector&lt;uint8_t&gt;</code> and <code>char*</code>.</p>
<div class="fragment"><div class="line">std::vector&lt;uint8_t&gt; data({1, 2, 3, 4});</div>
<div class="line">auto result = webSocket.sendBinary(data);</div>
<div class="line"> </div>
<div class="line">const char* text = &quot;Hello World!&quot;;</div>
<div class="line">result = webSocket.sendUtf8Text(IXWebSocketSendData(text, strlen(text)));</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1743"></a>
ReadyState</h2>
<p><code>getReadyState()</code> returns the state of the connection. There are 4 possible states.</p>
<ol type="1">
<li>ReadyState::Connecting - The connection is not yet open.</li>
<li>ReadyState::Open - The connection is open and ready to communicate.</li>
<li>ReadyState::Closing - The connection is in the process of closing.</li>
<li>ReadyState::Closed - The connection is closed or could not be opened.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1744"></a>
Open and Close notifications</h2>
<p>The onMessage event will be fired when the connection is opened or closed. This is similar to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">JavaScript browser API</a>, which has <code>open</code> and <code>close</code> events notification that can be registered with the browser <code>addEventListener</code>.</p>
<div class="fragment"><div class="line">webSocket.setOnMessageCallback([](<span class="keyword">const</span> ix::WebSocketMessagePtr&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Open)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;send greetings&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Headers can be inspected (pairs of string/string)</span></div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Handshake Headers:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            for (auto it : msg-&gt;headers)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; it.first &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; it.second &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Close)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;disconnected&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// The server can send an explicit code and reason for closing.</span></div>
<div class="line">            <span class="comment">// This data can be accessed through the closeInfo object.</span></div>
<div class="line">            std::cout &lt;&lt; msg-&gt;closeInfo.code &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; msg-&gt;closeInfo.reason &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1745"></a>
Error notification</h2>
<p><a class="el" href="class_a.html">A</a> message will be fired when there is an error with the connection. The message type will be <code>ix::WebSocketMessageType::Error</code>. Multiple fields will be available on the event to describe the error.</p>
<div class="fragment"><div class="line">webSocket.setOnMessageCallback([](<span class="keyword">const</span> ix::WebSocketMessagePtr&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Error)</div>
<div class="line">        {</div>
<div class="line">            std::stringstream ss;</div>
<div class="line">            ss &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span>         &lt;&lt; msg-&gt;errorInfo.reason      &lt;&lt; std::endl;</div>
<div class="line">            ss &lt;&lt; <span class="stringliteral">&quot;#retries: &quot;</span>      &lt;&lt; msg-&gt;errorInfo.retries     &lt;&lt; std::endl;</div>
<div class="line">            ss &lt;&lt; <span class="stringliteral">&quot;Wait time(ms): &quot;</span> &lt;&lt; msg-&gt;errorInfo.wait_time   &lt;&lt; std::endl;</div>
<div class="line">            ss &lt;&lt; <span class="stringliteral">&quot;HTTP Status: &quot;</span>   &lt;&lt; msg-&gt;errorInfo.http_status &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; ss.str() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1746"></a>
start, stop</h2>
<ol type="1">
<li><code>websocket.start()</code> connect to the remote server and starts the message receiving background thread.</li>
<li><code>websocket.stop()</code> disconnect from the remote server and closes the background thread.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1747"></a>
Configuring the remote url</h2>
<p>The url can be set and queried after a websocket object has been created. You will have to call <code>stop</code> and <code>start</code> if you want to disconnect and connect to that new url.</p>
<div class="fragment"><div class="line">std::string url(<span class="stringliteral">&quot;wss://example.com&quot;</span>);</div>
<div class="line">websocket.configure(url);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1748"></a>
Ping/Pong support</h2>
<p>Ping/pong messages are used to implement keep-alive. 2 message types exists to identify ping and pong messages. Note that when a ping message is received, a pong is instantly send back as requested by the WebSocket spec.</p>
<div class="fragment"><div class="line">webSocket.setOnMessageCallback([](<span class="keyword">const</span> ix::WebSocketMessagePtr&amp; msg)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Ping ||</div>
<div class="line">            msg-&gt;type == ix::WebSocketMessageType::Pong)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;pong data: &quot;</span> &lt;&lt; msg-&gt;str &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">);</div>
</div><!-- fragment --><p><a class="el" href="class_a.html">A</a> ping message can be sent to the server, with an optional data string.</p>
<div class="fragment"><div class="line">websocket.ping(<span class="stringliteral">&quot;ping data, optional (empty string is ok): limited to 125 bytes long&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1749"></a>
Heartbeat.</h2>
<p>You can configure an optional heart beat / keep-alive, sent every 45 seconds when there is no any traffic to make sure that load balancers do not kill an idle connection.</p>
<div class="fragment"><div class="line">webSocket.setPingInterval(45);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1750"></a>
Supply extra HTTP headers.</h2>
<p>You can set extra <a class="el" href="struct_h_t_t_p.html">HTTP</a> headers to be sent during the WebSocket handshake.</p>
<div class="fragment"><div class="line">WebSocketHttpHeaders headers;</div>
<div class="line">headers[<span class="stringliteral">&quot;foo&quot;</span>] = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line">webSocket.setExtraHeaders(headers);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1751"></a>
Subprotocols</h2>
<p>You can specify subprotocols to be set during the WebSocket handshake. For more info you can refer to <a href="https://hpbn.co/websocket/#subprotocol-negotiation">this doc</a>.</p>
<div class="fragment"><div class="line">webSocket.addSubprotocol(<span class="stringliteral">&quot;appProtocol-v1&quot;</span>);</div>
<div class="line">webSocket.addSubprotocol(<span class="stringliteral">&quot;appProtocol-v2&quot;</span>);</div>
</div><!-- fragment --><p>The protocol that the server did accept is available in the open info <code>protocol</code> field.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;protocol: &quot;</span> &lt;&lt; msg-&gt;openInfo.protocol &lt;&lt; std::endl;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1752"></a>
Automatic reconnection</h2>
<p>Automatic reconnection kicks in when the connection is disconnected without the user consent. This feature is on by default and can be turned off.</p>
<div class="fragment"><div class="line">webSocket.enableAutomaticReconnection();  <span class="comment">// turn on</span></div>
<div class="line">webSocket.disableAutomaticReconnection(); <span class="comment">// turn off</span></div>
<div class="line"><span class="keywordtype">bool</span> enabled = webSocket.isAutomaticReconnectionEnabled(); <span class="comment">// query state</span></div>
</div><!-- fragment --><p>The technique to calculate wait time is called <a href="https://docs.aws.amazon.com/general/latest/gr/api-retries.html">exponential backoff</a>. Here are the default waiting times between attempts (from connecting with <code>ws connect ws://foo.com</code>)</p>
<div class="fragment"><div class="line">&gt; Connection error: Got bad status connecting to foo.com, status: 301, HTTP Status line: HTTP/1.1 301 Moved Permanently</div>
<div class="line"> </div>
<div class="line">#retries: 1</div>
<div class="line">Wait time(ms): 100</div>
<div class="line">#retries: 2</div>
<div class="line">Wait time(ms): 200</div>
<div class="line">#retries: 3</div>
<div class="line">Wait time(ms): 400</div>
<div class="line">#retries: 4</div>
<div class="line">Wait time(ms): 800</div>
<div class="line">#retries: 5</div>
<div class="line">Wait time(ms): 1600</div>
<div class="line">#retries: 6</div>
<div class="line">Wait time(ms): 3200</div>
<div class="line">#retries: 7</div>
<div class="line">Wait time(ms): 6400</div>
<div class="line">#retries: 8</div>
<div class="line">Wait time(ms): 10000</div>
</div><!-- fragment --><p>The waiting time is capped by default at 10s between 2 attempts, but that value can be changed and queried. The minimum waiting time can also be set.</p>
<div class="fragment"><div class="line">webSocket.setMaxWaitBetweenReconnectionRetries(5 * 1000); <span class="comment">// 5000ms = 5s</span></div>
<div class="line">uint32_t m = webSocket.getMaxWaitBetweenReconnectionRetries();</div>
<div class="line"> </div>
<div class="line">webSocket.setMinWaitBetweenReconnectionRetries(1000); <span class="comment">// 1000ms = 1s</span></div>
<div class="line">uint32_t m = webSocket.getMinWaitBetweenReconnectionRetries();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1753"></a>
Handshake timeout</h1>
<p>You can control how long to wait until timing out while waiting for the websocket handshake to be performed.</p>
<div class="fragment"><div class="line">int handshakeTimeoutSecs = 1;</div>
<div class="line">setHandshakeTimeout(handshakeTimeoutSecs);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1754"></a>
WebSocket server API</h1>
<h2><a class="anchor" id="autotoc_md1755"></a>
Legacy api</h2>
<p>This api was actually changed to take a weak_ptr&lt;WebSocket&gt; as the first argument to setOnConnectionCallback ; previously it would take a shared_ptr&lt;WebSocket&gt; which was creating cycles and then memory leaks problems.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXWebSocketServer.h&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run a server on localhost at a given port.</span></div>
<div class="line"><span class="comment">// Bound host name, max connections and listen backlog can also be passed in as parameters.</span></div>
<div class="line">ix::WebSocketServer server(port);</div>
<div class="line"> </div>
<div class="line">server.setOnConnectionCallback(</div>
<div class="line">    [&amp;server](std::weak_ptr&lt;WebSocket&gt; webSocket,</div>
<div class="line">              std::shared_ptr&lt;ConnectionState&gt; connectionState)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Remote ip: &quot;</span> &lt;&lt; connectionState-&gt;remoteIp &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">auto</span> ws = webSocket.lock();</div>
<div class="line">        <span class="keywordflow">if</span> (ws)</div>
<div class="line">        {</div>
<div class="line">            ws-&gt;setOnMessageCallback(</div>
<div class="line">                [webSocket, connectionState, &amp;server](<span class="keyword">const</span> ix::WebSocketMessagePtr msg)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Open)</div>
<div class="line">                    {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;New connection&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// A connection state object is available, and has a default id</span></div>
<div class="line">                        <span class="comment">// You can subclass ConnectionState and pass an alternate factory</span></div>
<div class="line">                        <span class="comment">// to override it. It is useful if you want to store custom</span></div>
<div class="line">                        <span class="comment">// attributes per connection (authenticated bool flag, attributes, etc...)</span></div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;id: &quot;</span> &lt;&lt; connectionState-&gt;getId() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">                        <span class="comment">// The uri the client did connect to.</span></div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Uri: &quot;</span> &lt;&lt; msg-&gt;openInfo.uri &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Headers:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        for (auto it : msg-&gt;openInfo.headers)</div>
<div class="line">                        {</div>
<div class="line">                            std::cout &lt;&lt; it.first &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; it.second &lt;&lt; std::endl;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Message)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// For an echo server, we just send back to the client whatever was received by the server</span></div>
<div class="line">                        <span class="comment">// All connected clients are available in an std::set. See the broadcast cpp example.</span></div>
<div class="line">                        <span class="comment">// Second parameter tells whether we are sending the message in binary or text mode.</span></div>
<div class="line">                        <span class="comment">// Here we send it in the same mode as it was received.</span></div>
<div class="line">                        auto ws = webSocket.lock();</div>
<div class="line">                        if (ws)</div>
<div class="line">                        {</div>
<div class="line">                            ws-&gt;send(msg-&gt;str, msg-&gt;binary);</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        );</div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = server.listen();</div>
<div class="line"><span class="keywordflow">if</span> (!res.first)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error handling</span></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Per message deflate connection is enabled by default. It can be disabled</span></div>
<div class="line"><span class="comment">// which might be helpful when running on low power devices such as a Rasbery Pi</span></div>
<div class="line">server.disablePerMessageDeflate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run the server in the background. Server can be stoped by calling server.stop()</span></div>
<div class="line">server.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Block until server.stop() is called.</span></div>
<div class="line">server.wait();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1756"></a>
New api</h2>
<p>The new API does not require to use 2 nested callbacks, which is a bit annoying. The real fix is that there was a memory leak due to a shared_ptr cycle, due to passing down a shared_ptr&lt;WebSocket&gt; down to the callbacks.</p>
<p>The webSocket reference is guaranteed to be always valid ; by design the callback will never be invoked with a null webSocket object.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXWebSocketServer.h&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run a server on localhost at a given port.</span></div>
<div class="line"><span class="comment">// Bound host name, max connections and listen backlog can also be passed in as parameters.</span></div>
<div class="line">ix::WebSocketServer server(port);</div>
<div class="line"> </div>
<div class="line">server.setOnClientMessageCallback([](std::shared_ptr&lt;ix::ConnectionState&gt; connectionState, <a class="code hl_class" href="classix_1_1_web_socket.html">ix::WebSocket</a> &amp; webSocket, <span class="keyword">const</span> ix::WebSocketMessagePtr &amp; msg) {</div>
<div class="line">    <span class="comment">// The ConnectionState object contains information about the connection,</span></div>
<div class="line">    <span class="comment">// at this point only the client ip address and the port.</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Remote ip: &quot;</span> &lt;&lt; connectionState-&gt;getRemoteIp() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Open)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;New connection&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// A connection state object is available, and has a default id</span></div>
<div class="line">        <span class="comment">// You can subclass ConnectionState and pass an alternate factory</span></div>
<div class="line">        <span class="comment">// to override it. It is useful if you want to store custom</span></div>
<div class="line">        <span class="comment">// attributes per connection (authenticated bool flag, attributes, etc...)</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;id: &quot;</span> &lt;&lt; connectionState-&gt;getId() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// The uri the client did connect to.</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Uri: &quot;</span> &lt;&lt; msg-&gt;openInfo.uri &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Headers:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        for (auto it : msg-&gt;openInfo.headers)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; it.first &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; it.second &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msg-&gt;type == ix::WebSocketMessageType::Message)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// For an echo server, we just send back to the client whatever was received by the server</span></div>
<div class="line">        <span class="comment">// All connected clients are available in an std::set. See the broadcast cpp example.</span></div>
<div class="line">        <span class="comment">// Second parameter tells whether we are sending the message in binary or text mode.</span></div>
<div class="line">        <span class="comment">// Here we send it in the same mode as it was received.</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received: &quot;</span> &lt;&lt; msg-&gt;str &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        webSocket.send(msg-&gt;str, msg-&gt;binary);</div>
<div class="line">    }</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = server.listen();</div>
<div class="line"><span class="keywordflow">if</span> (!res.first)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Error handling</span></div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Per message deflate connection is enabled by default. It can be disabled</span></div>
<div class="line"><span class="comment">// which might be helpful when running on low power devices such as a Rasbery Pi</span></div>
<div class="line">server.disablePerMessageDeflate();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run the server in the background. Server can be stoped by calling server.stop()</span></div>
<div class="line">server.start();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Block until server.stop() is called.</span></div>
<div class="line">server.wait();</div>
<div class="ttc" id="aclassix_1_1_web_socket_html"><div class="ttname"><a href="classix_1_1_web_socket.html">ix::WebSocket</a></div><div class="ttdef"><b>Definition:</b> IXWebSocket.h:44</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1757"></a>
HTTP client API</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXHttpClient.h&gt;</span></div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Preparation</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">HttpClient httpClient;</div>
<div class="line">HttpRequestArgsPtr args = httpClient.createRequest();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Custom headers can be set</span></div>
<div class="line">WebSocketHttpHeaders headers;</div>
<div class="line">headers[<span class="stringliteral">&quot;Foo&quot;</span>] = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line">args-&gt;extraHeaders = headers;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Timeout options</span></div>
<div class="line">args-&gt;connectTimeout = connectTimeout;</div>
<div class="line">args-&gt;transferTimeout = transferTimeout;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Redirect options</span></div>
<div class="line">args-&gt;followRedirects = followRedirects;</div>
<div class="line">args-&gt;maxRedirects = maxRedirects;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Misc</span></div>
<div class="line">args-&gt;compress = compress; <span class="comment">// Enable gzip compression</span></div>
<div class="line">args-&gt;verbose = verbose;</div>
<div class="line">args-&gt;logger = [](<span class="keyword">const</span> std::string&amp; msg)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; msg;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Synchronous Request</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line">HttpResponsePtr out;</div>
<div class="line">std::string url = <span class="stringliteral">&quot;https://www.google.com&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// HEAD request</span></div>
<div class="line">out = httpClient.head(url, args);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// GET request</span></div>
<div class="line">out = httpClient.get(url, args);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POST request with parameters</span></div>
<div class="line">HttpParameters httpParameters;</div>
<div class="line">httpParameters[<span class="stringliteral">&quot;foo&quot;</span>] = <span class="stringliteral">&quot;bar&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// HTTP form data can be passed in as well, for multi-part upload of files</span></div>
<div class="line">HttpFormDataParameters httpFormDataParameters;</div>
<div class="line">httpParameters[<span class="stringliteral">&quot;baz&quot;</span>] = <span class="stringliteral">&quot;booz&quot;</span>;</div>
<div class="line"> </div>
<div class="line">out = httpClient.post(url, httpParameters, httpFormDataParameters, args);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// POST request with a body</span></div>
<div class="line">out = httpClient.post(url, std::string(<span class="stringliteral">&quot;foo=bar&quot;</span>), args);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// PUT and PATCH are available too.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Result</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keyword">auto</span> statusCode = response-&gt;statusCode; <span class="comment">// Can be HttpErrorCode::Ok, HttpErrorCode::UrlMalformed, etc...</span></div>
<div class="line"><span class="keyword">auto</span> errorCode = response-&gt;errorCode; <span class="comment">// 200, 404, etc...</span></div>
<div class="line"><span class="keyword">auto</span> responseHeaders = response-&gt;headers; <span class="comment">// All the headers in a special case-insensitive unordered_map of (string, string)</span></div>
<div class="line"><span class="keyword">auto</span> body = response-&gt;body; <span class="comment">// All the bytes from the response as an std::string</span></div>
<div class="line"><span class="keyword">auto</span> errorMsg = response-&gt;errorMsg; <span class="comment">// Descriptive error message in case of failure</span></div>
<div class="line"><span class="keyword">auto</span> uploadSize = response-&gt;uploadSize; <span class="comment">// Byte count of uploaded data</span></div>
<div class="line"><span class="keyword">auto</span> downloadSize = response-&gt;downloadSize; <span class="comment">// Byte count of downloaded data</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Asynchronous Request</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="keywordtype">bool</span> async = <span class="keyword">true</span>;</div>
<div class="line">HttpClient httpClient(async);</div>
<div class="line"><span class="keyword">auto</span> args = httpClient.createRequest(url, HttpClient::kGet);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If you define a chunk callback it will be called repeteadly with the</span></div>
<div class="line"><span class="comment">// incoming data. This allows to process data on the go or write it to disk</span></div>
<div class="line"><span class="comment">// instead of accumulating the data in memory.</span></div>
<div class="line">args.onChunkCallback = [](<span class="keyword">const</span> std::string&amp; <a class="code hl_struct" href="structdata.html">data</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// process data</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Push the request to a queue,</span></div>
<div class="line"><span class="keywordtype">bool</span> ok = httpClient.performRequest(args, [](<span class="keyword">const</span> HttpResponsePtr&amp; response)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// This callback execute in a background thread. Make sure you uses appropriate protection such as mutex</span></div>
<div class="line">        <span class="keyword">auto</span> statusCode = response-&gt;statusCode; <span class="comment">// acess results</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// response-&gt;body is empty if onChunkCallback was used</span></div>
<div class="line">    }</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ok will be false if your httpClient is not async</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A request in progress can be cancelled by setting the cancel flag. It does nothing if the request already completed.</span></div>
<div class="line">args-&gt;cancel = <span class="keyword">true</span>;</div>
<div class="ttc" id="astructdata_html"><div class="ttname"><a href="structdata.html">data</a></div><div class="ttdef"><b>Definition:</b> debug.c:29</div></div>
</div><!-- fragment --><p>See this <a href="https://github.com/machinezone/IXWebSocket/issues/209">issue</a> for links about uploading files with <a class="el" href="struct_h_t_t_p.html">HTTP</a> multipart.</p>
<h1><a class="anchor" id="autotoc_md1758"></a>
HTTP server API</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;ixwebsocket/IXHttpServer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classix_1_1_http_server.html">ix::HttpServer</a> server(port, <a class="code hl_struct" href="structhostname.html">hostname</a>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res = server.listen();</div>
<div class="line"><span class="keywordflow">if</span> (!res.first)</div>
<div class="line">{</div>
<div class="line">    std::cerr &lt;&lt; res.second &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">server.start();</div>
<div class="line">server.wait();</div>
<div class="ttc" id="aclassix_1_1_http_server_html"><div class="ttname"><a href="classix_1_1_http_server.html">ix::HttpServer</a></div><div class="ttdef"><b>Definition:</b> IXHttpServer.h:23</div></div>
<div class="ttc" id="astructhostname_html"><div class="ttname"><a href="structhostname.html">hostname</a></div><div class="ttdef"><b>Definition:</b> urldata.h:532</div></div>
</div><!-- fragment --><p>If you want to handle how requests are processed, implement the setOnConnectionCallback callback, which takes an HttpRequestPtr as input, and returns an HttpResponsePtr. You can look at HttpServer::setDefaultConnectionCallback for a slightly more advanced callback example.</p>
<div class="fragment"><div class="line">setOnConnectionCallback(</div>
<div class="line">    [<span class="keyword">this</span>](HttpRequestPtr request,</div>
<div class="line">           std::shared_ptr&lt;ConnectionState&gt; connectionState) -&gt; HttpResponsePtr</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Build a string for the response</span></div>
<div class="line">        std::stringstream ss;</div>
<div class="line">        ss &lt;&lt; connectionState-&gt;getRemoteIp();</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">           &lt;&lt; request-&gt;method</div>
<div class="line">           &lt;&lt; <span class="stringliteral">&quot; &quot;</span></div>
<div class="line">           &lt;&lt; request-&gt;uri;</div>
<div class="line"> </div>
<div class="line">        std::string <a class="code hl_struct" href="structcontent.html">content</a> = ss.str();</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> std::make_shared&lt;HttpResponse&gt;(200, <span class="stringliteral">&quot;OK&quot;</span>,</div>
<div class="line">                                              HttpErrorCode::Ok,</div>
<div class="line">                                              WebSocketHttpHeaders(),</div>
<div class="line">                                              <a class="code hl_struct" href="structcontent.html">content</a>);</div>
<div class="line">}</div>
<div class="ttc" id="astructcontent_html"><div class="ttname"><a href="structcontent.html">content</a></div><div class="ttdef"><b>Definition:</b> archive_read_support_format_iso9660.c:254</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1759"></a>
TLS support and configuration</h1>
<p>To leverage TLS features, the library must be compiled with the option <code>USE_TLS=1</code>.</p>
<p>If you are using OpenSSL, try to be on a version higher than 1.1.x as there there are thread safety problems with 1.0.x.</p>
<p>Then, secure sockets are automatically used when connecting to a <code>wss://*</code> url.</p>
<p>Additional TLS options can be configured by passing a <code><a class="el" href="structix_1_1_socket_t_l_s_options.html">ix::SocketTLSOptions</a></code> instance to the <code>setTLSOptions</code> on <code><a class="el" href="classix_1_1_web_socket.html">ix::WebSocket</a></code> (or <code><a class="el" href="classix_1_1_web_socket_server.html">ix::WebSocketServer</a></code> or <code><a class="el" href="classix_1_1_http_server.html">ix::HttpServer</a></code>)</p>
<div class="fragment"><div class="line">webSocket.setTLSOptions({</div>
<div class="line">    .certFile = <span class="stringliteral">&quot;path/to/cert/file.pem&quot;</span>,</div>
<div class="line">    .keyFile = <span class="stringliteral">&quot;path/to/key/file.pem&quot;</span>,</div>
<div class="line">    .caFile = <span class="stringliteral">&quot;path/to/trust/bundle/file.pem&quot;</span>, <span class="comment">// as a file, or in memory buffer in PEM format</span></div>
<div class="line">    .tls = <span class="keyword">true</span> <span class="comment">// required in server mode</span></div>
<div class="line">});</div>
</div><!-- fragment --><p>Specifying <code>certFile</code> and <code>keyFile</code> configures the certificate that will be used to communicate with TLS peers.</p>
<p>On a client, this is only necessary for connecting to servers that require a client certificate.</p>
<p>On a server, this is necessary for TLS support.</p>
<p>Specifying <code>caFile</code> configures the trusted roots bundle file (in PEM format) that will be used to verify peer certificates.</p><ul>
<li>The special value of <code>SYSTEM</code> (the default) indicates that the system-configured trust bundle should be used; this is generally what you want when connecting to any publicly exposed API/server.</li>
<li>The special value of <code>NONE</code> can be used to disable peer verification; this is only recommended to rule out certificate verification when testing connectivity.</li>
<li>If the value contain the special value <code>-----BEGIN CERTIFICATE-----</code>, the value will be read from memory, and not from a file. This is convenient on platforms like Android where reading / writing to the file system can be challenging without proper permissions, or without knowing the location of a temp directory.</li>
</ul>
<p>For a client, specifying <code>caFile</code> can be used if connecting to a server that uses a self-signed cert, or when using a custom CA in an internal environment.</p>
<p>For a server, specifying <code>caFile</code> implies that:</p><ol type="1">
<li>You require clients to present a certificate</li>
</ol>
<ol type="1">
<li>It must be signed by one of the trusted roots in the file </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
