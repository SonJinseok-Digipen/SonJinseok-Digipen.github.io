
\begin{DoxyItemize}
\item \mbox{\hyperlink{index_intro}{Intro}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_git}{git}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Portability}{Portability}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_winvsunix}{Windows vs Unix}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Library}{Library}}
\begin{DoxyItemize}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_connect}{\`{}\+Curl\+\_\+connect\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_do}{\`{}multi\+\_\+do\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_readwrite}{\`{}\+Curl\+\_\+readwrite\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_done}{\`{}multi\+\_\+done\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_disconnect}{\`{}\+Curl\+\_\+disconnect\`{}}}
\end{DoxyItemize}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_http}{HTTP(S)}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ftp}{FTP}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_kerberos}{Kerberos}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_telnet}{TELNET}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_file}{FILE}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_smb}{SMB}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ldap}{LDAP}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_email}{E-\/mail}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_general}{General}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_persistent}{Persistent Connections}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi}{multi interface/non-\/blocking}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ssl}{SSL libraries}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_symbols}{Library Symbols}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_returncodes}{Return Codes and Informationals}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_abi}{AP/\+ABI}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_client}{Client}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memorydebug}{Memory Debugging}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_test}{Test Suite}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_asyncdns}{Asynchronous name resolves}}
\begin{DoxyItemize}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_cares}{c-\/ares}}
\end{DoxyItemize}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curl_off_t}{\`{}curl\+\_\+off\+\_\+t\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curlx}{curlx}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_contentencoding}{Content Encoding}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_hostip}{\`{}hostip.c\`{} explained}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memoryleak}{Track Down Memory Leaks}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_socket}{\`{}multi\+\_\+socket\`{}}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_structs}{Structs in libcurl}}
\begin{DoxyItemize}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_easy}{Curl\+\_\+easy}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_connectdata}{connectdata}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_multi}{Curl\+\_\+multi}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_handler}{Curl\+\_\+handler}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_conncache}{conncache}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_share}{Curl\+\_\+share}}
\item \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_CookieInfo}{Cookie\+Info}}
\end{DoxyItemize}
\end{DoxyItemize}

\label{index_intro}%
\Hypertarget{index_intro}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1019}{}\doxysection{Intro}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1019}
This project is split in two. The library and the client. The client part uses the library, but the library is designed to allow other applications to use it.

The largest amount of code and complexity is in the library part.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_git}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_git}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1020}{}\doxysection{git}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1020}
All changes to the sources are committed to the git repository as soon as they\textquotesingle{}re somewhat verified to work. Changes shall be committed as independently as possible so that individual changes can be easily spotted and tracked afterwards.

Tagging shall be used extensively, and by the time we release new archives we should tag the sources with a name similar to the released version number.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Portability}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Portability}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1021}{}\doxysection{Portability}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1021}
We write curl and libcurl to compile with C89 compilers. On 32-\/bit and up machines. Most of libcurl assumes more or less POSIX compliance but that\textquotesingle{}s not a requirement.

We write libcurl to build and work with lots of third party tools, and we want it to remain functional and buildable with these and later versions (older versions may still work but is not what we work hard to maintain)\+:\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1022}{}\doxysubsection{Dependencies}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1022}

\begin{DoxyItemize}
\item Open\+SSL 0.\+9.\+7
\item Gnu\+TLS 3.\+1.\+10
\item zlib 1.\+1.\+4
\item libssh2 1.\+0
\item c-\/ares 1.\+16.\+0
\item libidn2 2.\+0.\+0
\item wolf\+SSL 2.\+0.\+0
\item openldap 2.\+0
\item MIT Kerberos 1.\+2.\+4
\item GSKit V5\+R3\+M0
\item NSS 3.\+14.\+x
\item Heimdal ?
\item nghttp2 1.\+12.\+0
\item Win\+Sock 2.\+2 (on Windows 95+ and Windows CE .NET 4.\+1+)
\end{DoxyItemize}\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1023}{}\doxysubsection{Operating Systems}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1023}
On systems where configure runs, we aim at working on them all -\/ if they have a suitable C compiler. On systems that don\textquotesingle{}t run configure, we strive to keep curl running correctly on\+:


\begin{DoxyItemize}
\item Windows 98
\item AS/400 V5\+R3\+M0
\item Symbian 9.\+1
\item Windows CE ?
\item TPF ?
\end{DoxyItemize}\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1024}{}\doxysubsection{Build tools}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1024}
When writing code (mostly for generating stuff included in release tarballs) we use a few \char`\"{}build tools\char`\"{} and we make sure that we remain functional with these versions\+:


\begin{DoxyItemize}
\item GNU Libtool 1.\+4.\+2
\item GNU Autoconf 2.\+57
\item GNU Automake 1.\+7
\item GNU M4 1.\+4
\item perl 5.\+004
\item roffit 0.\+5
\item groff ? (any version that supports {\ttfamily groff -\/Tps -\/man \mbox{[}in\mbox{]} \mbox{[}out\mbox{]}})
\item ps2pdf (gs) ?
\end{DoxyItemize}

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_winvsunix}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_winvsunix}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1025}{}\doxysection{Windows vs Unix}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1025}
There are a few differences in how to program curl the Unix way compared to the Windows way. Perhaps the four most notable details are\+:


\begin{DoxyEnumerate}
\item Different function names for socket operations.

In curl, this is solved with defines and macros, so that the source looks the same in all places except for the header file that defines them. The macros in use are {\ttfamily sclose()}, {\ttfamily sread()} and {\ttfamily swrite()}.
\item Windows requires a couple of init calls for the socket stuff.

That\textquotesingle{}s taken care of by the {\ttfamily curl\+\_\+global\+\_\+init()} call, but if other libs also do it etc there might be reasons for applications to alter that behavior.

We require Win\+Sock version 2.\+2 and load this version during global init.
\item The file descriptors for network communication and file operations are not as easily interchangeable as in Unix.

We avoid this by not trying any funny tricks on file descriptors.
\item When writing data to stdout, Windows makes end-\/of-\/lines the DOS way, thus destroying binary data, although you do want that conversion if it is text coming through... (sigh)

We set stdout to binary under windows
\end{DoxyEnumerate}

Inside the source code, We make an effort to avoid {\ttfamily \#ifdef \mbox{[}Your OS\mbox{]}}. All conditionals that deal with features {\itshape should} instead be in the format {\ttfamily \#ifdef HAVE\+\_\+\+THAT\+\_\+\+WEIRD\+\_\+\+FUNCTION}. Since Windows can\textquotesingle{}t run configure scripts, we maintain a {\ttfamily curl\+\_\+config-\/win32.\+h} file in lib directory that is supposed to look exactly like a {\ttfamily curl\+\_\+config.\+h} file would have looked like on a Windows machine!

Generally speaking\+: always remember that this will be compiled on dozens of operating systems. Don\textquotesingle{}t walk on the edge!

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Library}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Library}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1026}{}\doxysection{Library}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1026}
(See \mbox{\hyperlink{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_structs}{Structs in libcurl}} for the separate section describing all major internal structs and their purposes.)

There are plenty of entry points to the library, namely each publicly defined function that libcurl offers to applications. All of those functions are rather small and easy-\/to-\/follow. All the ones prefixed with {\ttfamily curl\+\_\+easy} are put in the {\ttfamily lib/easy.\+c} file.

{\ttfamily curl\+\_\+global\+\_\+init()} and {\ttfamily curl\+\_\+global\+\_\+cleanup()} should be called by the application to initialize and clean up global stuff in the library. As of today, it can handle the global SSL initialization if SSL is enabled and it can initialize the socket layer on Windows machines. libcurl itself has no \char`\"{}global\char`\"{} scope.

All printf()-\/style functions use the supplied clones in {\ttfamily lib/mprintf.\+c}. This makes sure we stay absolutely platform independent.

\href{https://curl.se/libcurl/c/curl_easy_init.html}{\texttt{ {\ttfamily curl\+\_\+easy\+\_\+init()}}} allocates an internal struct and makes some initializations. The returned handle does not reveal internals. This is the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct which works as an \char`\"{}anchor\char`\"{} struct for all {\ttfamily curl\+\_\+easy} functions. All connections performed will get connect-\/specific data allocated that should be used for things related to particular connections/requests.

\href{https://curl.se/libcurl/c/curl_easy_setopt.html}{\texttt{ {\ttfamily curl\+\_\+easy\+\_\+setopt()}}} takes three arguments, where the option stuff must be passed in pairs\+: the parameter-\/\+ID and the parameter-\/value. The list of options is documented in the man page. This function mainly sets things in the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct.

{\ttfamily curl\+\_\+easy\+\_\+perform()} is just a wrapper function that makes use of the multi API. It basically calls {\ttfamily curl\+\_\+multi\+\_\+init()}, {\ttfamily curl\+\_\+multi\+\_\+add\+\_\+handle()}, {\ttfamily curl\+\_\+multi\+\_\+wait()}, and {\ttfamily curl\+\_\+multi\+\_\+perform()} until the transfer is done and then returns.

Some of the most important key functions in {\ttfamily url.\+c} are called from {\ttfamily multi.\+c} when certain key steps are to be made in the transfer operation.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_connect}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_connect}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1027}{}\doxysubsection{Curl\+\_\+connect()}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1027}
Analyzes the URL, it separates the different components and connects to the remote host. This may involve using a proxy and/or using SSL. The {\ttfamily Curl\+\_\+resolv()} function in {\ttfamily lib/hostip.\+c} is used for looking up host names (it does then use the proper underlying method, which may vary between platforms and builds).

When {\ttfamily Curl\+\_\+connect} is done, we are connected to the remote site. Then it is time to tell the server to get a document/file. {\ttfamily Curl\+\_\+do()} arranges this.

This function makes sure there\textquotesingle{}s an allocated and initiated {\ttfamily connectdata} struct that is used for this particular connection only (although there may be several requests performed on the same connect). \mbox{\hyperlink{class_a}{A}} bunch of things are initialized/inherited from the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_do}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_do}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1028}{}\doxysubsection{multi\+\_\+do()}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1028}
{\ttfamily multi\+\_\+do()} makes sure the proper protocol-\/specific function is called. The functions are named after the protocols they handle.

The protocol-\/specific functions of course deal with protocol-\/specific negotiations and setup. When they\textquotesingle{}re ready to start the actual file transfer they call the {\ttfamily Curl\+\_\+setup\+\_\+transfer()} function (in {\ttfamily lib/transfer.\+c}) to setup the transfer and returns.

If this DO function fails and the connection is being re-\/used, libcurl will then close this connection, setup a new connection and re-\/issue the DO request on that. This is because there is no way to be perfectly sure that we have discovered a dead connection before the DO function and thus we might wrongly be re-\/using a connection that was closed by the remote peer.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_readwrite}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_readwrite}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1029}{}\doxysubsection{Curl\+\_\+readwrite()}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1029}
Called during the transfer of the actual protocol payload.

During transfer, the progress functions in {\ttfamily lib/progress.\+c} are called at frequent intervals (or at the user\textquotesingle{}s choice, a specified callback might get called). The speedcheck functions in {\ttfamily lib/speedcheck.\+c} are also used to verify that the transfer is as fast as required.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_done}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_done}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1030}{}\doxysubsection{multi\+\_\+done()}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1030}
Called after a transfer is done. This function takes care of everything that has to be done after a transfer. This function attempts to leave matters in a state so that {\ttfamily multi\+\_\+do()} should be possible to call again on the same connection (in a persistent connection case). It might also soon be closed with {\ttfamily Curl\+\_\+disconnect()}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_disconnect}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_disconnect}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1031}{}\doxysubsection{Curl\+\_\+disconnect()}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1031}
When doing normal connections and transfers, no one ever tries to close any connections so this is not normally called when {\ttfamily curl\+\_\+easy\+\_\+perform()} is used. This function is only used when we are certain that no more transfers are going to be made on the connection. It can be also closed by force, or it can be called to make sure that libcurl doesn\textquotesingle{}t keep too many connections alive at the same time.

This function cleans up all resources that are associated with a single connection.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_http}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_http}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1032}{}\doxysection{HTTP(\+S)}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1032}
\mbox{\hyperlink{struct_h_t_t_p}{HTTP}} offers a lot and is the protocol in curl that uses the most lines of code. There is a special file {\ttfamily lib/formdata.\+c} that offers all the multipart post functions.

base64-\/functions for user+password stuff (and more) is in {\ttfamily lib/base64.\+c} and all functions for parsing and sending cookies are found in {\ttfamily lib/cookie.\+c}.

HTTPS uses in almost every case the same procedure as \mbox{\hyperlink{struct_h_t_t_p}{HTTP}}, with only two exceptions\+: the connect procedure is different and the function used to read or write from the socket is different, although the latter fact is hidden in the source by the use of {\ttfamily Curl\+\_\+read()} for reading and {\ttfamily Curl\+\_\+write()} for writing data to the remote server.

{\ttfamily http\+\_\+chunks.\+c} contains functions that understands \mbox{\hyperlink{struct_h_t_t_p}{HTTP}} 1.\+1 chunked transfer encoding.

An interesting detail with the HTTP(\+S) request, is the {\ttfamily Curl\+\_\+add\+\_\+buffer()} series of functions we use. They append data to one single buffer, and when the building is finished the entire request is sent off in one single write. This is done this way to overcome problems with flawed firewalls and lame servers.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ftp}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ftp}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1033}{}\doxysection{FTP}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1033}
The {\ttfamily Curl\+\_\+if2ip()} function can be used for getting the IP number of a specified network interface, and it resides in {\ttfamily lib/if2ip.\+c}.

{\ttfamily Curl\+\_\+ftpsendf()} is used for sending \mbox{\hyperlink{struct_f_t_p}{FTP}} commands to the remote server. It was made a separate function to prevent us programmers from forgetting that they must be CRLF terminated. They must also be sent in one single {\ttfamily write()} to make firewalls and similar happy.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_kerberos}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_kerberos}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1034}{}\doxysection{Kerberos}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1034}
Kerberos support is mainly in {\ttfamily lib/krb5.\+c} but also {\ttfamily curl\+\_\+sasl\+\_\+sspi.\+c} and {\ttfamily curl\+\_\+sasl\+\_\+gssapi.\+c} for the email protocols and {\ttfamily socks\+\_\+gssapi.\+c} and {\ttfamily socks\+\_\+sspi.\+c} for SOCKS5 proxy specifics.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_telnet}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_telnet}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1035}{}\doxysection{TELNET}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1035}
Telnet is implemented in {\ttfamily lib/telnet.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_file}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_file}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1036}{}\doxysection{FILE}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1036}
The {\ttfamily \href{file://}{\texttt{ file\+://}}} protocol is dealt with in {\ttfamily lib/file.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_smb}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_smb}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1037}{}\doxysection{SMB}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1037}
The {\ttfamily smb\+://} protocol is dealt with in {\ttfamily lib/smb.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ldap}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ldap}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1038}{}\doxysection{LDAP}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1038}
Everything LDAP is in {\ttfamily lib/ldap.\+c} and {\ttfamily lib/openldap.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_email}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_email}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1039}{}\doxysection{E-\/mail}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1039}
The e-\/mail related source code is in {\ttfamily lib/imap.\+c}, {\ttfamily lib/pop3.\+c} and {\ttfamily lib/smtp.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_general}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_general}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1040}{}\doxysection{General}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1040}
URL encoding and decoding, called escaping and unescaping in the source code, is found in {\ttfamily lib/escape.\+c}.

While transferring data in {\ttfamily Transfer()} a few functions might get used. {\ttfamily curl\+\_\+getdate()} in {\ttfamily lib/parsedate.\+c} is for \mbox{\hyperlink{struct_h_t_t_p}{HTTP}} date comparisons (and more).

{\ttfamily lib/getenv.\+c} offers {\ttfamily curl\+\_\+getenv()} which is for reading environment variables in a neat platform independent way. That\textquotesingle{}s used in the client, but also in {\ttfamily lib/url.\+c} when checking the proxy environment variables. Note that contrary to the normal unix {\ttfamily getenv()}, this returns an allocated buffer that must be {\ttfamily free()}ed after use.

{\ttfamily lib/netrc.\+c} holds the {\ttfamily .netrc} parser.

{\ttfamily lib/timeval.\+c} features replacement functions for systems that don\textquotesingle{}t have {\ttfamily gettimeofday()} and a few support functions for timeval conversions.

\mbox{\hyperlink{class_a}{A}} function named {\ttfamily curl\+\_\+version()} that returns the full curl version string is found in {\ttfamily lib/version.\+c}.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_persistent}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_persistent}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1041}{}\doxysection{Persistent Connections}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1041}
The persistent connection support in libcurl requires some considerations on how to do things inside of the library.


\begin{DoxyItemize}
\item The {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct returned in the \href{https://curl.se/libcurl/c/curl_easy_init.html}{\texttt{ {\ttfamily curl\+\_\+easy\+\_\+init()}}} call must never hold connection-\/oriented data. It is meant to hold the root data as well as all the options etc that the library-\/user may choose.
\item The {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct holds the \char`\"{}connection cache\char`\"{} (an array of pointers to {\ttfamily connectdata} structs).
\item This enables the \textquotesingle{}curl handle\textquotesingle{} to be reused on subsequent transfers.
\item When libcurl is told to perform a transfer, it first checks for an already existing connection in the cache that we can use. Otherwise it creates a new one and adds that to the cache. If the cache is full already when a new connection is added, it will first close the oldest unused one.
\item When the transfer operation is complete, the connection is left open. Particular options may tell libcurl not to, and protocols may signal closure on connections and then they won\textquotesingle{}t be kept open, of course.
\item When {\ttfamily curl\+\_\+easy\+\_\+cleanup()} is called, we close all still opened connections, unless of course the multi interface \char`\"{}owns\char`\"{} the connections.
\end{DoxyItemize}

The curl handle must be re-\/used in order for the persistent connections to work.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1042}{}\doxysection{multi interface/non-\/blocking}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1042}
The multi interface is a non-\/blocking interface to the library. To make that interface work as well as possible, no low-\/level functions within libcurl must be written to work in a blocking manner. (There are still a few spots violating this rule.)

One of the primary reasons we introduced c-\/ares support was to allow the name resolve phase to be perfectly non-\/blocking as well.

The \mbox{\hyperlink{struct_f_t_p}{FTP}} and the SFTP/\+SCP protocols are examples of how we adapt and adjust the code to allow non-\/blocking operations even on multi-\/stage command-\/ response protocols. They are built around state machines that return when they would otherwise block waiting for data. The DICT, LDAP and \mbox{\hyperlink{struct_t_e_l_n_e_t}{TELNET}} protocols are crappy examples and they are subject for rewrite in the future to better fit the libcurl protocol family.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ssl}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_ssl}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1043}{}\doxysection{SSL libraries}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1043}
Originally libcurl supported SSLeay for SSL/\+TLS transports, but that was then extended to its successor Open\+SSL but has since also been extended to several other SSL/\+TLS libraries and we expect and hope to further extend the support in future libcurl versions.

To deal with this internally in the best way possible, we have a generic SSL function API as provided by the {\ttfamily vtls/vtls.\mbox{[}ch\mbox{]}} system, and they are the only SSL functions we must use from within libcurl. vtls is then crafted to use the appropriate lower-\/level function calls to whatever SSL library that is in use. For example {\ttfamily vtls/openssl.\mbox{[}ch\mbox{]}} for the Open\+SSL library.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_symbols}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_symbols}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1044}{}\doxysection{Library Symbols}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1044}
All symbols used internally in libcurl must use a {\ttfamily Curl\+\_\+} prefix if they\textquotesingle{}re used in more than a single file. Single-\/file symbols must be made static. Public (\char`\"{}exported\char`\"{}) symbols must use a {\ttfamily curl\+\_\+} prefix. (There are exceptions, but they are to be changed to follow this pattern in future versions.) Public API functions are marked with {\ttfamily CURL\+\_\+\+EXTERN} in the public header files so that all others can be hidden on platforms where this is possible.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_returncodes}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_returncodes}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1045}{}\doxysection{Return Codes and Informationals}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1045}
I\textquotesingle{}ve made things simple. Almost every function in libcurl returns a CURLcode, that must be {\ttfamily CURLE\+\_\+\+OK} if everything is OK or otherwise a suitable error code as the {\ttfamily \mbox{\hyperlink{curl_8h_source}{curl/curl.\+h}}} include file defines. The very spot that detects an error must use the {\ttfamily Curl\+\_\+failf()} function to set the human-\/readable error description.

In aiding the user to understand what\textquotesingle{}s happening and to debug curl usage, we must supply a fair number of informational messages by using the {\ttfamily Curl\+\_\+infof()} function. Those messages are only displayed when the user explicitly asks for them. They are best used when revealing information that isn\textquotesingle{}t otherwise obvious.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_abi}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_abi}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1046}{}\doxysection{API/\+ABI}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1046}
We make an effort to not export or show internals or how internals work, as that makes it easier to keep a solid API/\+ABI over time. See docs/libcurl/\+ABI for our promise to users.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_client}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_client}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1047}{}\doxysection{Client}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1047}
{\ttfamily main()} resides in {\ttfamily src/tool\+\_\+main.\+c}.

{\ttfamily src/tool\+\_\+hugehelp.\+c} is automatically generated by the {\ttfamily mkhelp.\+pl} perl script to display the complete \char`\"{}manual\char`\"{} and the {\ttfamily src/tool\+\_\+urlglob.\+c} file holds the functions used for the URL-\/\char`\"{}globbing\char`\"{} support. Globbing in the sense that the {\ttfamily \{\}} and {\ttfamily \mbox{[}\mbox{]}} expansion stuff is there.

The client mostly sets up its {\ttfamily config} struct properly, then it calls the {\ttfamily curl\+\_\+easy\+\_\+$\ast$()} functions of the library and when it gets back control after the {\ttfamily curl\+\_\+easy\+\_\+perform()} it cleans up the library, checks status and exits.

When the operation is done, the {\ttfamily our\+Write\+Out()} function in {\ttfamily src/writeout.\+c} may be called to report about the operation. That function is mostly using the {\ttfamily curl\+\_\+easy\+\_\+getinfo()} function to extract useful information from the curl session.

It may loop and do all this several times if many URLs were specified on the command line or config file.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memorydebug}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memorydebug}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1048}{}\doxysection{Memory Debugging}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1048}
The file {\ttfamily lib/memdebug.\+c} contains debug-\/versions of a few functions. Functions such as {\ttfamily malloc()}, {\ttfamily free()}, {\ttfamily fopen()}, {\ttfamily fclose()}, etc that somehow deal with resources that might give us problems if we \char`\"{}leak\char`\"{} them. The functions in the memdebug system do nothing fancy, they do their normal function and then log information about what they just did. The logged data can then be analyzed after a complete session,

{\ttfamily memanalyze.\+pl} is the perl script present in {\ttfamily tests/} that analyzes a log file generated by the memory tracking system. It detects if resources are allocated but never freed and other kinds of errors related to resource management.

Internally, definition of preprocessor symbol {\ttfamily DEBUGBUILD} restricts code which is only compiled for debug enabled builds. And symbol {\ttfamily CURLDEBUG} is used to differentiate code which is {\itshape only} used for memory tracking/debugging.

Use {\ttfamily -\/DCURLDEBUG} when compiling to enable memory debugging, this is also switched on by running configure with {\ttfamily -\/-\/enable-\/curldebug}. Use {\ttfamily -\/DDEBUGBUILD} when compiling to enable a debug build or run configure with {\ttfamily -\/-\/enable-\/debug}.

{\ttfamily curl -\/-\/version} will list \textquotesingle{}Debug\textquotesingle{} feature for debug enabled builds, and will list \textquotesingle{}Track\+Memory\textquotesingle{} feature for curl debug memory tracking capable builds. These features are independent and can be controlled when running the configure script. When {\ttfamily -\/-\/enable-\/debug} is given both features will be enabled, unless some restriction prevents memory tracking from being used.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_test}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_test}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1049}{}\doxysection{Test Suite}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1049}
The test suite is placed in its own subdirectory directly off the root in the curl archive tree, and it contains a bunch of scripts and a lot of test case data.

The main test script is {\ttfamily runtests.\+pl} that will invoke test servers like {\ttfamily httpserver.\+pl} and {\ttfamily ftpserver.\+pl} before all the test cases are performed. The test suite currently only runs on Unix-\/like platforms.

You\textquotesingle{}ll find a description of the test suite in the {\ttfamily tests/\+README} file, and the test case data files in the {\ttfamily tests/\+FILEFORMAT} file.

The test suite automatically detects if curl was built with the memory debugging enabled, and if it was, it will detect memory leaks, too.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_asyncdns}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_asyncdns}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1050}{}\doxysection{Asynchronous name resolves}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1050}
libcurl can be built to do name resolves asynchronously, using either the normal resolver in a threaded manner or by using c-\/ares.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_cares}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_cares}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1051}{}\doxysubsection{$<$a href=\char`\"{}https\+://c-\/ares.\+org/\char`\"{} $>$c-\/ares$<$/a$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1051}
\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1052}{}\doxysubsubsection{Build libcurl to use a c-\/ares}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1052}

\begin{DoxyEnumerate}
\item ./configure --enable-\/ares=/path/to/ares/install
\item make
\end{DoxyEnumerate}\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1053}{}\doxysubsubsection{c-\/ares on win32}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1053}
First I compiled c-\/ares. I changed the default C runtime library to be the single-\/threaded rather than the multi-\/threaded (this seems to be required to prevent linking errors later on). Then I simply build the areslib project (the other projects adig/ahost seem to fail under MSVC).

Next was libcurl. I opened {\ttfamily \mbox{\hyperlink{config-win32_8h_source}{lib/config-\/win32.\+h}}} and I added a\+: {\ttfamily \#define USE\+\_\+\+ARES 1}

Next thing I did was I added the path for the ares includes to the include path, and the libares.\+lib to the libraries.

Lastly, I also changed libcurl to be single-\/threaded rather than multi-\/threaded, again this was to prevent some duplicate symbol errors. I\textquotesingle{}m not sure why I needed to change everything to single-\/threaded, but when I didn\textquotesingle{}t I got redefinition errors for several CRT functions ({\ttfamily malloc()}, {\ttfamily stricmp()}, etc.)

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curl_off_t}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curl_off_t}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1054}{}\doxysection{$<$tt$>$curl\+\_\+off\+\_\+t$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1054}
{\ttfamily curl\+\_\+off\+\_\+t} is a data type provided by the external libcurl include headers. It is the type meant to be used for the \href{https://curl.se/libcurl/c/curl_easy_setopt.html}{\texttt{ {\ttfamily curl\+\_\+easy\+\_\+setopt()}}} options that end with LARGE. The type is 64-\/bit large on most modern platforms.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curlx}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_curlx}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1055}{}\doxysection{curlx}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1055}
The libcurl source code offers a few functions by source only. They are not part of the official libcurl API, but the source files might be useful for others so apps can optionally compile/build with these sources to gain additional functions.

We provide them through a single header file for easy access for apps\+: {\ttfamily \mbox{\hyperlink{curlx_8h_source}{curlx.\+h}}}\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1056}{}\doxysubsection{$<$tt$>$curlx\+\_\+strtoofft()$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1056}
\mbox{\hyperlink{class_a}{A}} macro that converts a string containing a number to a {\ttfamily curl\+\_\+off\+\_\+t} number. This might use the {\ttfamily curlx\+\_\+strtoll()} function which is provided as source code in strtoofft.\+c. Note that the function is only provided if no {\ttfamily strtoll()} (or equivalent) function exist on your platform. If {\ttfamily curl\+\_\+off\+\_\+t} is only a 32-\/bit number on your platform, this macro uses {\ttfamily strtol()}.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1057}{}\doxysubsection{Future}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1057}
Several functions will be removed from the public {\ttfamily curl\+\_\+} name space in a future libcurl release. They will then only become available as {\ttfamily curlx\+\_\+} functions instead. To make the transition easier, we already today provide these functions with the {\ttfamily curlx\+\_\+} prefix to allow sources to be built properly with the new function names. The concerned functions are\+:


\begin{DoxyItemize}
\item {\ttfamily curlx\+\_\+getenv}
\item {\ttfamily curlx\+\_\+strequal}
\item {\ttfamily curlx\+\_\+strnequal}
\item {\ttfamily curlx\+\_\+mvsnprintf}
\item {\ttfamily curlx\+\_\+msnprintf}
\item {\ttfamily curlx\+\_\+maprintf}
\item {\ttfamily curlx\+\_\+mvaprintf}
\item {\ttfamily curlx\+\_\+msprintf}
\item {\ttfamily curlx\+\_\+mprintf}
\item {\ttfamily curlx\+\_\+mfprintf}
\item {\ttfamily curlx\+\_\+mvsprintf}
\item {\ttfamily curlx\+\_\+mvprintf}
\item {\ttfamily curlx\+\_\+mvfprintf}
\end{DoxyItemize}

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_contentencoding}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_contentencoding}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1058}{}\doxysection{Content Encoding}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1058}
\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1059}{}\doxysubsection{About content encodings}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1059}
\href{https://tools.ietf.org/html/rfc7230}{\texttt{ HTTP/1.\+1}} specifies that a client may request that a server encode its response. This is usually used to compress a response using one (or more) encodings from a set of commonly available compression techniques. These schemes include {\ttfamily deflate} (the zlib algorithm), {\ttfamily gzip}, {\ttfamily br} (brotli) and {\ttfamily compress}. \mbox{\hyperlink{class_a}{A}} client requests that the server perform an encoding by including an {\ttfamily Accept-\/\+Encoding} header in the request document. The value of the header should be one of the recognized tokens {\ttfamily deflate}, ... (there\textquotesingle{}s a way to register new schemes/tokens, see sec 3.\+5 of the spec). \mbox{\hyperlink{class_a}{A}} server MAY honor the client\textquotesingle{}s encoding request. When a response is encoded, the server includes a {\ttfamily Content-\/\+Encoding} header in the response. The value of the {\ttfamily Content-\/\+Encoding} header indicates which encodings were used to encode the data, in the order in which they were applied.

It\textquotesingle{}s also possible for a client to attach priorities to different schemes so that the server knows which it prefers. See sec 14.\+3 of RFC 2616 for more information on the {\ttfamily Accept-\/\+Encoding} header. See sec \href{https://tools.ietf.org/html/rfc7231\#section-3.1.2.2}{\texttt{ 3.\+1.\+2.\+2 of RFC 7231}} for more information on the {\ttfamily Content-\/\+Encoding} header.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1060}{}\doxysubsection{Supported content encodings}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1060}
The {\ttfamily deflate}, {\ttfamily gzip} and {\ttfamily br} content encodings are supported by libcurl. Both regular and chunked transfers work fine. The zlib library is required for the {\ttfamily deflate} and {\ttfamily gzip} encodings, while the brotli decoding library is for the {\ttfamily br} encoding.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1061}{}\doxysubsection{The libcurl interface}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1061}
To cause libcurl to request a content encoding use\+:

\href{https://curl.se/libcurl/c/curl_easy_setopt.html}{\texttt{ {\ttfamily curl\+\_\+easy\+\_\+setopt}}}(curl, \href{https://curl.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html}{\texttt{ {\ttfamily CURLOPT\+\_\+\+ACCEPT\+\_\+\+ENCODING}}}, string)

where string is the intended value of the {\ttfamily Accept-\/\+Encoding} header.

Currently, libcurl does support multiple encodings but only understands how to process responses that use the {\ttfamily deflate}, {\ttfamily gzip} and/or {\ttfamily br} content encodings, so the only values for \href{https://curl.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html}{\texttt{ {\ttfamily CURLOPT\+\_\+\+ACCEPT\+\_\+\+ENCODING}}} that will work (besides {\ttfamily identity}, which does nothing) are {\ttfamily deflate}, {\ttfamily gzip} and {\ttfamily br}. If a response is encoded using the {\ttfamily compress} or methods, libcurl will return an error indicating that the response could not be decoded. If {\ttfamily \texorpdfstring{$<$}{<}string\texorpdfstring{$>$}{>}} is NULL no {\ttfamily Accept-\/\+Encoding} header is generated. If {\ttfamily \texorpdfstring{$<$}{<}string\texorpdfstring{$>$}{>}} is a zero-\/length string, then an {\ttfamily Accept-\/\+Encoding} header containing all supported encodings will be generated.

The \href{https://curl.se/libcurl/c/CURLOPT_ACCEPT_ENCODING.html}{\texttt{ {\ttfamily CURLOPT\+\_\+\+ACCEPT\+\_\+\+ENCODING}}} must be set to any non-\/\+NULL value for content to be automatically decoded. If it is not set and the server still sends encoded content (despite not having been asked), the data is returned in its raw form and the {\ttfamily Content-\/\+Encoding} type is not checked.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1062}{}\doxysubsection{The curl interface}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1062}
Use the \href{https://curl.se/docs/manpage.html\#--compressed}{\texttt{ {\ttfamily -\/-\/compressed}}} option with curl to cause it to ask servers to compress responses using any format supported by curl.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_hostip}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_hostip}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1063}{}\doxysection{$<$tt$>$hostip.\+c$<$/tt$>$ explained}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1063}
The main compile-\/time defines to keep in mind when reading the {\ttfamily host$\ast$.c} source file are these\+:\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1064}{}\doxysubsection{$<$tt$>$\+CURLRES\+\_\+\+IPV6$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1064}
this host has {\ttfamily getaddrinfo()} and family, and thus we use that. The host may not be able to resolve IPv6, but we don\textquotesingle{}t really have to take that into account. Hosts that aren\textquotesingle{}t IPv6-\/enabled have {\ttfamily CURLRES\+\_\+\+IPV4} defined.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1065}{}\doxysubsection{$<$tt$>$\+CURLRES\+\_\+\+ARES$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1065}
is defined if libcurl is built to use c-\/ares for asynchronous name resolves. This can be Windows or $\ast$nix.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1066}{}\doxysubsection{$<$tt$>$\+CURLRES\+\_\+\+THREADED$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1066}
is defined if libcurl is built to use threading for asynchronous name resolves. The name resolve will be done in a new thread, and the supported asynch API will be the same as for ares-\/builds. This is the default under (native) Windows.

If any of the two previous are defined, {\ttfamily CURLRES\+\_\+\+ASYNCH} is defined too. If libcurl is not built to use an asynchronous resolver, {\ttfamily CURLRES\+\_\+\+SYNCH} is defined.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1067}{}\doxysubsection{$<$tt$>$host$\ast$.\+c$<$/tt$>$ sources}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1067}
The {\ttfamily host$\ast$.c} sources files are split up like this\+:


\begin{DoxyItemize}
\item {\ttfamily hostip.\+c} -\/ method-\/independent resolver functions and utility functions
\item {\ttfamily hostasyn.\+c} -\/ functions for asynchronous name resolves
\item {\ttfamily hostsyn.\+c} -\/ functions for synchronous name resolves
\item {\ttfamily asyn-\/ares.\+c} -\/ functions for asynchronous name resolves using c-\/ares
\item {\ttfamily asyn-\/thread.\+c} -\/ functions for asynchronous name resolves using threads
\item {\ttfamily hostip4.\+c} -\/ IPv4 specific functions
\item {\ttfamily hostip6.\+c} -\/ IPv6 specific functions
\end{DoxyItemize}

The {\ttfamily \mbox{\hyperlink{hostip_8h_source}{hostip.\+h}}} is the single united header file for all this. It defines the {\ttfamily CURLRES\+\_\+$\ast$} defines based on the {\ttfamily config$\ast$.h} and {\ttfamily \mbox{\hyperlink{curl__setup_8h_source}{curl\+\_\+setup.\+h}}} defines.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memoryleak}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_memoryleak}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1068}{}\doxysection{Track Down Memory Leaks}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1068}
\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1069}{}\doxysubsection{Single-\/threaded}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1069}
Please note that this memory leak system is not adjusted to work in more than one thread. If you want/need to use it in a multi-\/threaded app. Please adjust accordingly.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1070}{}\doxysubsection{Build}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1070}
Rebuild libcurl with {\ttfamily -\/DCURLDEBUG} (usually, rerunning configure with {\ttfamily -\/-\/enable-\/debug} fixes this). {\ttfamily make clean} first, then {\ttfamily make} so that all files are actually rebuilt properly. It will also make sense to build libcurl with the debug option (usually {\ttfamily -\/g} to the compiler) so that debugging it will be easier if you actually do find a leak in the library.

This will create a library that has memory debugging enabled.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1071}{}\doxysubsection{Modify Your Application}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1071}
Add a line in your application code\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{curl\_dbg\_memdebug(\textcolor{stringliteral}{"{}dump"{}});}

\end{DoxyCode}


This will make the malloc debug system output a full trace of all resource using functions to the given file name. Make sure you rebuild your program and that you link with the same libcurl you built for this purpose as described above.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1072}{}\doxysubsection{Run Your Application}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1072}
Run your program as usual. Watch the specified memory trace file grow.

Make your program exit and use the proper libcurl cleanup functions etc. So that all non-\/leaks are returned/freed properly.\hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1073}{}\doxysubsection{Analyze the Flow}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1073}
Use the {\ttfamily tests/memanalyze.\+pl} perl script to analyze the dump file\+:

tests/memanalyze.\+pl dump

This now outputs a report on what resources that were allocated but never freed etc. This report is very fine for posting to the list!

If this doesn\textquotesingle{}t produce any output, no leak was detected in libcurl. Then the leak is mostly likely to be in your code.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_socket}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_multi_socket}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1074}{}\doxysection{$<$tt$>$multi\+\_\+socket$<$/tt$>$}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1074}
Implementation of the {\ttfamily curl\+\_\+multi\+\_\+socket} API

The main ideas of this API are simply\+:


\begin{DoxyEnumerate}
\item The application can use whatever event system it likes as it gets info from libcurl about what file descriptors libcurl waits for what action on. (The previous API returns {\ttfamily fd\+\_\+sets} which is very {\ttfamily select()}-\/centric).
\item When the application discovers action on a single socket, it calls libcurl and informs that there was action on this particular socket and libcurl can then act on that socket/transfer only and not care about any other transfers. (The previous API always had to scan through all the existing transfers.)
\end{DoxyEnumerate}

The idea is that \href{https://curl.se/libcurl/c/curl_multi_socket_action.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+socket\+\_\+action()}}} calls a given callback with information about what socket to wait for what action on, and the callback only gets called if the status of that socket has changed.

We also added a timer callback that makes libcurl call the application when the timeout value changes, and you set that with \href{https://curl.se/libcurl/c/curl_multi_setopt.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+setopt()}}} and the \href{https://curl.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html}{\texttt{ {\ttfamily CURLMOPT\+\_\+\+TIMERFUNCTION}}} option. To get this to work, Internally, there\textquotesingle{}s an added struct to each easy handle in which we store an \char`\"{}expire time\char`\"{} (if any). The structs are then \char`\"{}splay sorted\char`\"{} so that we can add and remove times from the linked list and yet somewhat swiftly figure out both how long there is until the next nearest timer expires and which timer (handle) we should take care of now. Of course, the upside of all this is that we get a \href{https://curl.se/libcurl/c/curl_multi_timeout.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+timeout()}}} that should also work with old-\/style applications that use \href{https://curl.se/libcurl/c/curl_multi_perform.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+perform()}}}.

We created an internal \char`\"{}socket to easy handles\char`\"{} hash table that given a socket (file descriptor) returns the easy handle that waits for action on that socket. This hash is made using the already existing hash code (previously only used for the DNS cache).

To make libcurl able to report plain sockets in the socket callback, we had to re-\/organize the internals of the \href{https://curl.se/libcurl/c/curl_multi_fdset.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+fdset()}}} etc so that the conversion from sockets to {\ttfamily fd\+\_\+sets} for that function is only done in the last step before the data is returned. I also had to extend c-\/ares to get a function that can return plain sockets, as that library too returned only {\ttfamily fd\+\_\+sets} and that is no longer good enough. The changes done to c-\/ares are available in c-\/ares 1.\+3.\+1 and later.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_structs}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_structs}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1075}{}\doxysection{Structs in libcurl}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1075}
This section should cover 7.\+32.\+0 pretty accurately, but will make sense even for older and later versions as things don\textquotesingle{}t change drastically that often.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_easy}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_easy}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1076}{}\doxysubsection{Curl\+\_\+easy}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1076}
The {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct is the one returned to the outside in the external API as a {\ttfamily CURL $\ast$}. This is usually known as an easy handle in API documentations and examples.

Information and state that is related to the actual connection is in the {\ttfamily connectdata} struct. When a transfer is about to be made, libcurl will either create a new connection or re-\/use an existing one. The particular connectdata that is used by this handle is pointed out by {\ttfamily Curl\+\_\+easy-\/\texorpdfstring{$>$}{>}easy\+\_\+conn}.

Data and information that regard this particular single transfer is put in the {\ttfamily \mbox{\hyperlink{struct_single_request}{Single\+Request}}} sub-\/struct.

When the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} struct is added to a multi handle, as it must be in order to do any transfer, the {\ttfamily -\/\texorpdfstring{$>$}{>}multi} member will point to the {\ttfamily \mbox{\hyperlink{struct_curl__multi}{Curl\+\_\+multi}}} struct it belongs to. The {\ttfamily -\/\texorpdfstring{$>$}{>}prev} and {\ttfamily -\/\texorpdfstring{$>$}{>}next} members will then be used by the multi code to keep a linked list of {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} structs that are added to that same multi handle. libcurl always uses multi so {\ttfamily -\/\texorpdfstring{$>$}{>}multi} {\itshape will} point to a {\ttfamily \mbox{\hyperlink{struct_curl__multi}{Curl\+\_\+multi}}} when a transfer is in progress.

{\ttfamily -\/\texorpdfstring{$>$}{>}mstate} is the multi state of this particular {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}. When {\ttfamily multi\+\_\+runsingle()} is called, it will act on this handle according to which state it is in. The mstate is also what tells which sockets to return for a specific {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} when \href{https://curl.se/libcurl/c/curl_multi_fdset.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+fdset()}}} is called etc.

The libcurl source code generally use the name {\ttfamily data} for the variable that points to the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}.

When doing multiplexed HTTP/2 transfers, each {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} is associated with an individual stream, sharing the same connectdata struct. Multiplexing makes it even more important to keep things associated with the right thing!

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_connectdata}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_connectdata}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1077}{}\doxysubsection{connectdata}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1077}
\mbox{\hyperlink{class_a}{A}} general idea in libcurl is to keep connections around in a connection \char`\"{}cache\char`\"{} after they have been used in case they will be used again and then re-\/use an existing one instead of creating a new as it creates a significant performance boost.

Each {\ttfamily connectdata} identifies a single physical connection to a server. If the connection can\textquotesingle{}t be kept alive, the connection will be closed after use and then this struct can be removed from the cache and freed.

Thus, the same {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} can be used multiple times and each time select another {\ttfamily connectdata} struct to use for the connection. Keep this in mind, as it is then important to consider if options or choices are based on the connection or the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}.

Functions in libcurl will assume that {\ttfamily connectdata-\/\texorpdfstring{$>$}{>}data} points to the {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} that uses this connection (for the moment).

As a special complexity, some protocols supported by libcurl require a special disconnect procedure that is more than just shutting down the socket. It can involve sending one or more commands to the server before doing so. Since connections are kept in the connection cache after use, the original {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} may no longer be around when the time comes to shut down a particular connection. For this purpose, libcurl holds a special dummy {\ttfamily closure\+\_\+handle} {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} in the {\ttfamily \mbox{\hyperlink{struct_curl__multi}{Curl\+\_\+multi}}} struct to use when needed.

\mbox{\hyperlink{struct_f_t_p}{FTP}} uses two TCP connections for a typical transfer but it keeps both in this single struct and thus can be considered a single connection for most internal concerns.

The libcurl source code generally use the name {\ttfamily conn} for the variable that points to the connectdata.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_multi}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_multi}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1078}{}\doxysubsection{Curl\+\_\+multi}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1078}
Internally, the easy interface is implemented as a wrapper around multi interface functions. This makes everything multi interface.

{\ttfamily \mbox{\hyperlink{struct_curl__multi}{Curl\+\_\+multi}}} is the multi handle struct exposed as {\ttfamily CURLM $\ast$} in external APIs.

This struct holds a list of {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} structs that have been added to this handle with \href{https://curl.se/libcurl/c/curl_multi_add_handle.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+add\+\_\+handle()}}}. The start of the list is {\ttfamily -\/\texorpdfstring{$>$}{>}easyp} and {\ttfamily -\/\texorpdfstring{$>$}{>}num\+\_\+easy} is a counter of added {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}s.

{\ttfamily -\/\texorpdfstring{$>$}{>}msglist} is a linked list of messages to send back when \href{https://curl.se/libcurl/c/curl_multi_info_read.html}{\texttt{ {\ttfamily curl\+\_\+multi\+\_\+info\+\_\+read()}}} is called. Basically a node is added to that list when an individual {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}\textquotesingle{}s transfer has completed.

{\ttfamily -\/\texorpdfstring{$>$}{>}hostcache} points to the name cache. It is a hash table for looking up name to IP. The nodes have a limited life time in there and this cache is meant to reduce the time for when the same name is wanted within a short period of time.

{\ttfamily -\/\texorpdfstring{$>$}{>}timetree} points to a tree of {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}s, sorted by the remaining time until it should be checked -\/ normally some sort of timeout. Each {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} has one node in the tree.

{\ttfamily -\/\texorpdfstring{$>$}{>}sockhash} is a hash table to allow fast lookups of socket descriptor for which {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} uses that descriptor. This is necessary for the {\ttfamily multi\+\_\+socket} API.

{\ttfamily -\/\texorpdfstring{$>$}{>}conn\+\_\+cache} points to the connection cache. It keeps track of all connections that are kept after use. The cache has a maximum size.

{\ttfamily -\/\texorpdfstring{$>$}{>}closure\+\_\+handle} is described in the {\ttfamily connectdata} section.

The libcurl source code generally use the name {\ttfamily multi} for the variable that points to the {\ttfamily \mbox{\hyperlink{struct_curl__multi}{Curl\+\_\+multi}}} struct.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_handler}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_handler}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1079}{}\doxysubsection{Curl\+\_\+handler}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1079}
Each unique protocol that is supported by libcurl needs to provide at least one {\ttfamily \mbox{\hyperlink{struct_curl__handler}{Curl\+\_\+handler}}} struct. It defines what the protocol is called and what functions the main code should call to deal with protocol specific issues. In general, there\textquotesingle{}s a source file named {\ttfamily \mbox{[}protocol\mbox{]}.c} in which there\textquotesingle{}s a {\ttfamily struct \mbox{\hyperlink{struct_curl__handler}{Curl\+\_\+handler}} Curl\+\_\+handler\+\_\+\mbox{[}protocol\mbox{]}} declared. In {\ttfamily url.\+c} there\textquotesingle{}s then the main array with all individual {\ttfamily \mbox{\hyperlink{struct_curl__handler}{Curl\+\_\+handler}}} structs pointed to from a single array which is scanned through when a URL is given to libcurl to work with.

The concrete function pointer prototypes can be found in {\ttfamily \mbox{\hyperlink{urldata_8h_source}{lib/urldata.\+h}}}.

{\ttfamily -\/\texorpdfstring{$>$}{>}scheme} is the URL scheme name, usually spelled out in uppercase. That\textquotesingle{}s \char`\"{}\+HTTP\char`\"{} or \char`\"{}\+FTP\char`\"{} etc. SSL versions of the protocol need their own {\ttfamily \mbox{\hyperlink{struct_curl__handler}{Curl\+\_\+handler}}} setup so HTTPS separate from \mbox{\hyperlink{struct_h_t_t_p}{HTTP}}.

{\ttfamily -\/\texorpdfstring{$>$}{>}setup\+\_\+connection} is called to allow the protocol code to allocate protocol specific data that then gets associated with that {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} for the rest of this transfer. It gets freed again at the end of the transfer. It will be called before the {\ttfamily connectdata} for the transfer has been selected/created. Most protocols will allocate its private {\ttfamily struct \mbox{[}PROTOCOL\mbox{]}} here and assign {\ttfamily Curl\+\_\+easy-\/\texorpdfstring{$>$}{>}req.\+p.\mbox{[}protocol\mbox{]}} to it.

{\ttfamily -\/\texorpdfstring{$>$}{>}connect\+\_\+it} allows a protocol to do some specific actions after the TCP connect is done, that can still be considered part of the connection phase.

Some protocols will alter the {\ttfamily connectdata-\/\texorpdfstring{$>$}{>}recv\mbox{[}\mbox{]}} and {\ttfamily connectdata-\/\texorpdfstring{$>$}{>}send\mbox{[}\mbox{]}} function pointers in this function.

{\ttfamily -\/\texorpdfstring{$>$}{>}connecting} is similarly a function that keeps getting called as long as the protocol considers itself still in the connecting phase.

{\ttfamily -\/\texorpdfstring{$>$}{>}do\+\_\+it} is the function called to issue the transfer request. What we call the DO action internally. If the DO is not enough and things need to be kept getting done for the entire DO sequence to complete, {\ttfamily -\/\texorpdfstring{$>$}{>}doing} is then usually also provided. Each protocol that needs to do multiple commands or similar for do/doing need to implement their own state machines (see SCP, SFTP, \mbox{\hyperlink{struct_f_t_p}{FTP}}). Some protocols (only \mbox{\hyperlink{struct_f_t_p}{FTP}} and only due to historical reasons) has a separate piece of the DO state called {\ttfamily DO\+\_\+\+MORE}.

{\ttfamily -\/\texorpdfstring{$>$}{>}doing} keeps getting called while issuing the transfer request command(s)

{\ttfamily -\/\texorpdfstring{$>$}{>}done} gets called when the transfer is complete and DONE. That\textquotesingle{}s after the main data has been transferred.

{\ttfamily -\/\texorpdfstring{$>$}{>}do\+\_\+more} gets called during the {\ttfamily DO\+\_\+\+MORE} state. The \mbox{\hyperlink{struct_f_t_p}{FTP}} protocol uses this state when setting up the second connection.

{\ttfamily -\/\texorpdfstring{$>$}{>}proto\+\_\+getsock} {\ttfamily -\/\texorpdfstring{$>$}{>}doing\+\_\+getsock} {\ttfamily -\/\texorpdfstring{$>$}{>}domore\+\_\+getsock} {\ttfamily -\/\texorpdfstring{$>$}{>}perform\+\_\+getsock} Functions that return socket information. Which socket(s) to wait for which I/O action(s) during the particular multi state.

{\ttfamily -\/\texorpdfstring{$>$}{>}disconnect} is called immediately before the TCP connection is shutdown.

{\ttfamily -\/\texorpdfstring{$>$}{>}readwrite} gets called during transfer to allow the protocol to do extra reads/writes

{\ttfamily -\/\texorpdfstring{$>$}{>}attach} attaches a transfer to the connection.

{\ttfamily -\/\texorpdfstring{$>$}{>}defport} is the default report TCP or UDP port this protocol uses

{\ttfamily -\/\texorpdfstring{$>$}{>}protocol} is one or more bits in the {\ttfamily CURLPROTO\+\_\+$\ast$} set. The SSL versions have their \char`\"{}base\char`\"{} protocol set and then the SSL variation. Like \char`\"{}\+HTTP$\vert$\+HTTPS\char`\"{}.

{\ttfamily -\/\texorpdfstring{$>$}{>}flags} is a bitmask with additional information about the protocol that will make it get treated differently by the generic engine\+:


\begin{DoxyItemize}
\item {\ttfamily PROTOPT\+\_\+\+SSL} -\/ will make it connect and negotiate SSL
\item {\ttfamily PROTOPT\+\_\+\+DUAL} -\/ this protocol uses two connections
\item {\ttfamily PROTOPT\+\_\+\+CLOSEACTION} -\/ this protocol has actions to do before closing the connection. This flag is no longer used by code, yet still set for a bunch of protocol handlers.
\item {\ttfamily PROTOPT\+\_\+\+DIRLOCK} -\/ \char`\"{}direction lock\char`\"{}. The SSH protocols set this bit to limit which \char`\"{}direction\char`\"{} of socket actions that the main engine will concern itself with.
\item {\ttfamily PROTOPT\+\_\+\+NONETWORK} -\/ a protocol that doesn\textquotesingle{}t use network (read {\ttfamily file\+:})
\item {\ttfamily PROTOPT\+\_\+\+NEEDSPWD} -\/ this protocol needs a password and will use a default one unless one is provided
\item {\ttfamily PROTOPT\+\_\+\+NOURLQUERY} -\/ this protocol can\textquotesingle{}t handle a query part on the URL (?foo=bar)
\end{DoxyItemize}

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_conncache}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_conncache}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1080}{}\doxysubsection{conncache}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1080}
Is a hash table with connections for later re-\/use. Each {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} has a pointer to its connection cache. Each multi handle sets up a connection cache that all added {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}s share by default.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_share}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_Curl_share}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1081}{}\doxysubsection{Curl\+\_\+share}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1081}
The libcurl share API allocates a {\ttfamily \mbox{\hyperlink{struct_curl__share}{Curl\+\_\+share}}} struct, exposed to the external API as {\ttfamily CURLSH $\ast$}.

The idea is that the struct can have a set of its own versions of caches and pools and then by providing this struct in the {\ttfamily CURLOPT\+\_\+\+SHARE} option, those specific {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}}s will use the caches/pools that this share handle holds.

Then individual {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} structs can be made to share specific things that they otherwise wouldn\textquotesingle{}t, such as cookies.

The {\ttfamily \mbox{\hyperlink{struct_curl__share}{Curl\+\_\+share}}} struct can currently hold cookies, DNS cache and the SSL session cache.

\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_CookieInfo}%
\Hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_CookieInfo}%
 \hypertarget{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1082}{}\doxysubsection{Cookie\+Info}\label{md__ase_sprite_aseprite_third_party_curl_docs__i_n_t_e_r_n_a_l_s_autotoc_md1082}
This is the main cookie struct. It holds all known cookies and related information. Each {\ttfamily \mbox{\hyperlink{struct_curl__easy}{Curl\+\_\+easy}}} has its own private {\ttfamily \mbox{\hyperlink{struct_cookie_info}{Cookie\+Info}}} even when they are added to a multi handle. They can be made to share cookies by using the share API. 