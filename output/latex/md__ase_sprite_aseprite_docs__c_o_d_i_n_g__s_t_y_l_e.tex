\hypertarget{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md36}{}\doxysection{Basics}\label{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md36}
Basic statements\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ \{c++\}}
\DoxyCodeLine{void\ global\_function(int\ arg1,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ int\ arg2,\ //\ You\ can\ use\ "{}const"{}\ preferably}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ int\ arg3,\ ...)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ int\ value;}
\DoxyCodeLine{\ \ const\ int\ constValue\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ We\ prefer\ to\ use\ "{}var\ =\ (condition\ ?\ ...:\ ...)"{}\ instead\ of}
\DoxyCodeLine{\ \ //\ "{}var\ =\ condition\ ?\ ...:\ ...;"{}\ to\ make\ clear\ about\ the}
\DoxyCodeLine{\ \ //\ ternary\ operator\ limits.}
\DoxyCodeLine{\ \ int\ conditionalValue1\ =\ (condition\ ?\ 1:\ 2);}
\DoxyCodeLine{\ \ int\ conditionalValue2\ =\ (condition\ ?\ longVarName:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ otherLongVarName);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ If\ a\ condition\ will\ return,\ we\ prefer\ the\ "{}return"{}}
\DoxyCodeLine{\ \ //\ statement\ in\ its\ own\ line\ to\ avoid\ missing\ the\ "{}return"{}}
\DoxyCodeLine{\ \ //\ keyword\ when\ we\ read\ code.}
\DoxyCodeLine{\ \ if\ (condition)}
\DoxyCodeLine{\ \ \ \ return;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ You\ can\ use\ braces\ \{\}\ if\ the\ condition\ has\ multiple\ lines}
\DoxyCodeLine{\ \ //\ or\ the\ if-\/body\ has\ multiple\ lines.}
\DoxyCodeLine{\ \ if\ (condition1\ ||}
\DoxyCodeLine{\ \ \ \ \ \ condition2)\ \{}
\DoxyCodeLine{\ \ \ \ return;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ if\ (condition)\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ We\ prefer\ to\ avoid\ whitespaces\ between\ "{}var=initial\_value"{}}
\DoxyCodeLine{\ \ //\ or\ "{}var<limit"{}\ to\ see\ better\ the\ "{};\ "{}\ separation.\ Anyway\ it}
\DoxyCodeLine{\ \ //\ can\ depend\ on\ the\ specific\ condition/case,\ etc.}
\DoxyCodeLine{\ \ for\ (int\ i=0;\ i<10;\ ++i)\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ //\ Same\ case\ as\ in\ if-\/return.}
\DoxyCodeLine{\ \ \ \ if\ (condition)}
\DoxyCodeLine{\ \ \ \ \ \ break;}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ while\ (condition)\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ do\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}\ while\ (condition);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ switch\ (condition)\ \{}
\DoxyCodeLine{\ \ \ \ case\ 1:}
\DoxyCodeLine{\ \ \ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ \ \ break;}
\DoxyCodeLine{\ \ \ \ case\ 2:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ int\ varInsideCase;}
\DoxyCodeLine{\ \ \ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ \ \ break;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ default:}
\DoxyCodeLine{\ \ \ \ \ \ break;}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md37}{}\doxysection{Namespaces}\label{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md37}
Define namespaces with lower case\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ \{c++\}}
\DoxyCodeLine{namespace\ app\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ ...}
\DoxyCodeLine{}
\DoxyCodeLine{\}\ //\ namespace\ app}

\end{DoxyCode}
\hypertarget{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md38}{}\doxysection{Classes}\label{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md38}
Define classes with {\ttfamily Capital\+Case} and member functions with {\ttfamily camel\+Case}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ \{c++\}}
\DoxyCodeLine{class\ ClassName\ \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{\ \ ClassName()}
\DoxyCodeLine{\ \ \ \ :\ m\_memberVarA(1),}
\DoxyCodeLine{\ \ \ \ \ \ m\_memberVarB(2),}
\DoxyCodeLine{\ \ \ \ \ \ m\_memberVarC(3)\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ virtual\ \string~ClassName();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ We\ can\ return\ in\ the\ same\ line\ for\ getter-\/like\ functions}
\DoxyCodeLine{\ \ int\ memberVar()\ const\ \{\ return\ m\_memberVar;\ \}}
\DoxyCodeLine{\ \ void\ setMemberVar();}
\DoxyCodeLine{}
\DoxyCodeLine{protected:}
\DoxyCodeLine{\ \ virtual\ void\ onEvent1()\ \{\ \}\ //\ Do\ nothing\ functions\ can\ be\ defined\ as\ "{}\{\ \}"{}}
\DoxyCodeLine{\ \ virtual\ void\ onEvent2()\ =\ 0;}
\DoxyCodeLine{}
\DoxyCodeLine{private:}
\DoxyCodeLine{\ \ int\ m\_memberVarA;}
\DoxyCodeLine{\ \ int\ m\_memberVarB;}
\DoxyCodeLine{\ \ int\ m\_memberVarC;}
\DoxyCodeLine{\ \ int\ m\_memberVarD\ =\ 4;\ //\ We\ can\ initialize\ variables\ here\ too}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{class\ Special\ :\ public\ ClassName\ \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{\ \ Special();}
\DoxyCodeLine{}
\DoxyCodeLine{protected:}
\DoxyCodeLine{\ \ void\ onEvent2()\ override\ \{}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md39}{}\doxysection{Const}\label{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md39}

\begin{DoxyItemize}
\item \href{https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md\#nl26-use-conventional-const-notation}{\texttt{ NL.\+26\+: Use conventional const notation}}
\end{DoxyItemize}\hypertarget{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md40}{}\doxysection{C++17}\label{md__ase_sprite_aseprite_docs__c_o_d_i_n_g__s_t_y_l_e_autotoc_md40}
We are using C++17 standard. Some things cannot be used because we\textquotesingle{}re targetting mac\+OS 10.\+9, some notes are added about this\+:


\begin{DoxyItemize}
\item Use {\ttfamily nullptr} instead of {\ttfamily NULL} macro
\item Use {\ttfamily auto} for complex types, iterators, or when the variable type is obvious (e.\+g. {\ttfamily auto s = new Sprite;})
\item Use range-\/based for loops ({\ttfamily for (const auto\& item \+: values) \{ ... \}})
\item Use template alias ({\ttfamily template\texorpdfstring{$<$}{<}typename T\texorpdfstring{$>$}{>} alias = orig\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>};})
\item Use generic lambda functions
\item Use {\ttfamily std\+::shared\+\_\+ptr}, {\ttfamily std\+::unique\+\_\+ptr}, or {\ttfamily \mbox{\hyperlink{classbase_1_1_ref}{base\+::\+Ref}}}
\item Use {\ttfamily std\+::clamp}
\item Use {\ttfamily std\+::optional} but taking care of some limitations from mac\+OS 10.\+9\+:
\begin{DoxyItemize}
\item Use {\ttfamily std\+::optional\+::has\+\_\+value()} instead of {\ttfamily std\+::optional\+::operator bool()} (\href{https://github.com/aseprite/laf/commit/81622fcbb9e4a0edc14a02250c387bd6fa878708}{\texttt{ example}})
\item Use {\ttfamily std\+::optional\+::operator$\ast$()} instead of {\ttfamily std\+::optional\+::value()} (\href{https://github.com/aseprite/aseprite/commit/4471dab289cdd45762155ce0b16472e95a7f8642}{\texttt{ example}})
\end{DoxyItemize}
\item Use {\ttfamily std\+::variant} but taking care of some limitations from mac\+OS 10.\+9\+:
\begin{DoxyItemize}
\item Use {\ttfamily T$\ast$ p = std\+::get\+\_\+if\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(\&value)} instead of {\ttfamily T v = std\+::get\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(value)} or create an auxiliary {\ttfamily get\+\_\+value()} using {\ttfamily std\+::get\+\_\+if} function (\href{https://github.com/aseprite/aseprite/commit/dc0e57728ae2b10cd8365ff0a50263daa8fcc9ac\#diff-a59e14240d83bffc2ea917d7ddd7b2762576b0e9ab49bf823ba1a89c653ff978R98}{\texttt{ example}})
\item Don\textquotesingle{}t use {\ttfamily std\+::visit()}, use some alternative with switch-\/case and the {\ttfamily std\+::variant\+::index()} (\href{https://github.com/aseprite/aseprite/commit/574f58375332bb80ce5572fdedb1028617786e45}{\texttt{ example}})
\end{DoxyItemize}
\item Use {\ttfamily std\+::any} but taking care of some limitations from mac\+OS 10.\+9\+:
\begin{DoxyItemize}
\item Use {\ttfamily T$\ast$ p = std\+::any\+\_\+cast\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(\&value)} instead of {\ttfamily T v = std\+::any\+\_\+cast\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}(value)} (\href{https://github.com/aseprite/aseprite/commit/c8d4c60f07df27590381ef28001a40f8f785f50e}{\texttt{ example}})
\end{DoxyItemize}
\item Use {\ttfamily static constexpr T v = ...;}
\item You can use {\ttfamily \texorpdfstring{$<$}{<}atomic\texorpdfstring{$>$}{>}}, {\ttfamily \texorpdfstring{$<$}{<}thread\texorpdfstring{$>$}{>}}, {\ttfamily \texorpdfstring{$<$}{<}mutex\texorpdfstring{$>$}{>}}, and {\ttfamily \texorpdfstring{$<$}{<}condition\+\_\+variable\texorpdfstring{$>$}{>}}
\item Prefer {\ttfamily using T = ...;} instead of {\ttfamily typedef ... T}
\item Use {\ttfamily \mbox{[}\mbox{[}fallthrough\mbox{]}\mbox{]}} if needed
\item We use gcc 9.\+2 or clang 9.\+0 on Linux, so check the features available in \href{https://en.cppreference.com/w/cpp/compiler_support}{\texttt{ https\+://en.\+cppreference.\+com/w/cpp/compiler\+\_\+support}} 
\end{DoxyItemize}